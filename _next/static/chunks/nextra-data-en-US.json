{"/getting-started/installation":{"title":"Installation","data":{"":"Get started with Pumped Functions by installing the core package and any additional packages you need.","requirements#Requirements":"Node.js 18+: Pumped Functions requires Node.js version 18 or higher\nTypeScript: While not required, TypeScript is highly recommended for the best experience","package-manager#Package Manager":"Pumped Functions works with all major package managers:pnpm:\npnpm add @pumped-fn/core-next\nnpm:\nnpm install @pumped-fn/core-next\nyarn:\nyarn add @pumped-fn/core-next","core-package#Core Package":"The core package provides all the fundamental functionality:\n# Core library with executors, scopes, and reactive programming\npnpm add @pumped-fn/core-next\nWhat's included:\nExecutors (containers for values and dependencies)\nScopes (resolution contexts)\nReactive programming utilities\nMeta system for type validation\nHelper functions and utilities","react-integration#React Integration":"For React applications, install the React bindings:pnpm:\npnpm add @pumped-fn/react\nnpm:\nnpm install @pumped-fn/react\nyarn:\nyarn add @pumped-fn/react\nWhat's included:\nReact hooks (useResolves, useResolve, useUpdate)\nReact components (ScopeProvider, Resolves, Reselect)\nAutomatic reactivity with React's concurrent features\nServer-side rendering support","additional-utilities#Additional Utilities":"For full-stack applications, consider the extra utilities:pnpm:\npnpm add @pumped-fn/extra\nnpm:\nnpm install @pumped-fn/extra\nyarn:\nyarn add @pumped-fn/extra","development-setup#Development Setup":"For development, you might want to install additional tools:pnpm:\n# TypeScript (if not already installed)\npnpm add -D typescript\n# Testing utilities\npnpm add -D vitest @testing-library/react @testing-library/jest-dom\nnpm:\n# TypeScript (if not already installed)\nnpm install -D typescript\n# Testing utilities\nnpm install -D vitest @testing-library/react @testing-library/jest-dom\nyarn:\n# TypeScript (if not already installed)\nyarn add -D typescript\n# Testing utilities\nyarn add -D vitest @testing-library/react @testing-library/jest-dom","typescript-configuration#TypeScript Configuration":"For the best TypeScript experience, ensure your tsconfig.json includes:\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2020\",\n    \"lib\": [\"ES2020\", \"DOM\", \"DOM.Iterable\"],\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"bundler\",\n    \"allowSyntheticDefaultImports\": true,\n    \"esModuleInterop\": true,\n    \"jsx\": \"react-jsx\",\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true\n  }\n}","verification#Verification":"Verify your installation by creating a simple test:\nimport { exec, createScope } from '@pumped-fn/core-next';\n// Create a simple executor\nconst greeting = exec(() => 'Hello from Pumped Functions!');\n// Create a scope and resolve the executor\nconst scope = createScope();\nconst result = scope.resolve(greeting);\nconsole.log(result); // \"Hello from Pumped Functions!\"","next-steps#Next Steps":"Now that you have Pumped Functions installed, continue with:\nQuick Start - Learn the basics in 5 minutes\nYour First App - Build a complete application\nCore Concepts - Deep dive into executors and scopes","troubleshooting#Troubleshooting":"","common-issues#Common Issues":"Module not found errors:\nEnsure you're using Node.js 18+\nCheck that your package manager installed the dependencies correctly\nVerify your TypeScript configuration supports ES modules\nType errors:\nMake sure TypeScript is configured with strict: true\nInstall type definitions for React if using the React package\nCheck that your moduleResolution is set to \"bundler\" or \"node\"\nNeed help? Check our GitHub issues or start a discussion."}},"/getting-started/quick-start":{"title":"Quick Start","data":{"":"Learn Pumped Functions in 5 minutes! This guide will walk you through the core concepts and get you building reactive applications.","basic-concepts#Basic Concepts":"Pumped Functions is built around three main concepts:\nExecutors - Containers that hold values and define dependencies\nScopes - Resolution contexts that manage executor lifecycles\nReactivity - Automatic dependency tracking and updates","your-first-executor#Your First Executor":"Let's start with a simple executor:\nimport { exec, createScope } from '@pumped-fn/core-next';\n// Create an executor that returns a value\nconst greeting = exec(() => 'Hello, World!');\n// Create a scope to resolve executors\nconst scope = createScope();\n// Resolve the executor to get its value\nconst result = scope.resolve(greeting);\nconsole.log(result); // \"Hello, World!\"","executors-with-dependencies#Executors with Dependencies":"Executors can depend on other executors:\nimport { exec, createScope } from '@pumped-fn/core-next';\n// Base executors\nconst firstName = exec(() => 'John');\nconst lastName = exec(() => 'Doe');\n// Executor that depends on other executors\nconst fullName = exec(\n  (first: string, last: string) => `${first} ${last}`,\n  [firstName, lastName]\n);\nconst scope = createScope();\nconst result = scope.resolve(fullName);\nconsole.log(result); // \"John Doe\"","reactive-programming#Reactive Programming":"Make your executors reactive to automatically update when dependencies change:\nimport { exec, createScope } from '@pumped-fn/core-next';\n// Create a counter executor\nconst counter = exec(() => ({ count: 0 }));\n// Create a reactive executor that depends on the counter\nconst doubled = exec(\n  (state) => state.count * 2,\n  counter.reactive // .reactive makes it reactive\n);\nconst scope = createScope();\n// Initial values\nconsole.log(scope.resolve(doubled)); // 0\n// Update the counter\nscope.update(counter, (state) => ({ count: state.count + 1 }));\n// Doubled automatically updates\nconsole.log(scope.resolve(doubled)); // 2","react-integration#React Integration":"Use Pumped Functions with React for reactive UIs:\nimport React from 'react';\nimport { exec } from '@pumped-fn/core-next';\nimport { useResolves, useUpdate, ScopeProvider } from '@pumped-fn/react';\n// Create executors\nconst counter = exec(() => ({ count: 0 }));\nconst doubled = exec((state) => state.count * 2, counter.reactive);\nfunction Counter() {\n  // Resolve multiple executors at once\n  const [counterState, doubledValue] = useResolves(counter, doubled);\n  \n  // Get update function\n  const updateCounter = useUpdate(counter);\n  return (\n    <div>\n      <p>Count: {counterState.count}</p>\n      <p>Doubled: {doubledValue}</p>\n      <button onClick={() => updateCounter(s => ({ count: s.count + 1 }))}>\n        Increment\n      </button>\n    </div>\n  );\n}\nfunction App() {\n  return (\n    <ScopeProvider>\n      <Counter />\n    </ScopeProvider>\n  );\n}","advanced-patterns#Advanced Patterns":"","async-executors#Async Executors":"Executors can handle async operations:\nimport { exec, createScope } from '@pumped-fn/core-next';\n// Async executor\nconst userData = exec(async () => {\n  const response = await fetch('/api/user');\n  return response.json();\n});\nconst scope = createScope();\n// Resolve async executor\nconst user = await scope.resolve(userData);\nconsole.log(user);","object-dependencies#Object Dependencies":"Use objects to name your dependencies:\nimport { exec, createScope } from '@pumped-fn/core-next';\nconst userPreferences = exec(() => ({ theme: 'dark', lang: 'en' }));\nconst userProfile = exec(() => ({ name: 'John', email: 'john@example.com' }));\nconst appSettings = exec(\n  ({ preferences, profile }) => ({\n    ...preferences,\n    userName: profile.name,\n    userEmail: profile.email,\n  }),\n  {\n    preferences: userPreferences,\n    profile: userProfile,\n  }\n);\nconst scope = createScope();\nconst settings = scope.resolve(appSettings);\nconsole.log(settings);\n// { theme: 'dark', lang: 'en', userName: 'John', userEmail: 'john@example.com' }","lazy-resolution#Lazy Resolution":"Use .lazy for executors that should only resolve when needed:\nimport { exec, createScope } from '@pumped-fn/core-next';\nconst expensiveComputation = exec(() => {\n  console.log('Computing...');\n  return Math.random() * 1000;\n});\nconst maybeUseValue = exec(\n  (value: number) => value > 500 ? value : null,\n  expensiveComputation.lazy // Only resolves if needed\n);\nconst scope = createScope();\nconst result = scope.resolve(maybeUseValue);","testing#Testing":"Testing with Pumped Functions is straightforward:\nimport { describe, it, expect } from 'vitest';\nimport { exec, createScope } from '@pumped-fn/core-next';\ndescribe('Calculator', () => {\n  it('should add two numbers', () => {\n    const a = exec(() => 5);\n    const b = exec(() => 3);\n    const sum = exec((a: number, b: number) => a + b, [a, b]);\n    const scope = createScope();\n    const result = scope.resolve(sum);\n    expect(result).toBe(8);\n  });\n  it('should handle updates', () => {\n    const counter = exec(() => ({ count: 0 }));\n    const doubled = exec((state) => state.count * 2, counter.reactive);\n    const scope = createScope();\n    \n    expect(scope.resolve(doubled)).toBe(0);\n    \n    scope.update(counter, { count: 5 });\n    expect(scope.resolve(doubled)).toBe(10);\n  });\n});","key-takeaways#Key Takeaways":"Executors are containers - They hold values and define how to create them\nScopes manage resolution - Create a scope to resolve executors\nDependencies are explicit - Pass dependencies as the second parameter\nReactivity is opt-in - Use .reactive to make executors reactive\nReact integration is seamless - Use hooks like useResolves and useUpdate","next-steps#Next Steps":"Now that you understand the basics, explore:\nYour First App - Build a complete application\nCore Concepts - Deep dive into executors and scopes\nReact Integration - Advanced React patterns\nTesting - Comprehensive testing strategies","common-patterns#Common Patterns":"","state-management#State Management":"// Global state executor\nconst appState = exec(() => ({\n  user: null,\n  theme: 'light',\n  notifications: [],\n}));\n// Derived state\nconst isLoggedIn = exec(\n  (state) => state.user !== null,\n  appState.reactive\n);\n// Actions\nconst login = exec(\n  (user: User) => (state: AppState) => ({\n    ...state,\n    user,\n  }),\n  [userExecutor]\n);","api-integration#API Integration":"// API executor with caching\nconst apiClient = exec(() => new ApiClient());\nconst userProfile = exec(\n  async (client: ApiClient, userId: string) => {\n    return client.getUser(userId);\n  },\n  [apiClient, currentUserId]\n);","configuration#Configuration":"// Environment-based configuration\nconst config = exec(() => ({\n  apiUrl: process.env.API_URL || 'http://localhost:3000',\n  isDev: process.env.NODE_ENV === 'development',\n}));\n// Feature flags\nconst features = exec(\n  (config) => ({\n    newUI: config.isDev,\n    analytics: !config.isDev,\n  }),\n  config\n);\nReady to build something amazing? Let's create your first app!"}},"/":{"title":"Pumped Functions","data":{"":"A modern TypeScript functional programming library that provides container-based dependency injection and reactive programming patterns. Built with type safety and developer experience in mind.","why-pumped-functions#Why Pumped Functions?":"ðŸ”§ Container-based DI: Elegant dependency injection without the complexity\nâš¡ Reactive Programming: Built-in reactivity with automatic dependency tracking\nðŸŽ¯ Type Safety: Full TypeScript support with excellent inference\nðŸ”„ React Integration: Seamless React hooks and components\nðŸ“¦ Modular Design: Use only what you need\nðŸ§ª Testing-First: Comprehensive testing utilities included","key-features#Key Features":"","executors#Executors":"Executors are the core building blocks - containers that hold values and define how dependencies are resolved.\nimport { exec } from '@pumped-fn/core-next';\n// Simple executor\nconst greeting = exec(() => 'Hello World!');\n// Executor with dependencies\nconst userGreeting = exec((name: string) => `Hello ${name}!`, name);","reactive-programming#Reactive Programming":"Built-in reactivity that automatically tracks dependencies and updates when they change.\nconst counter = exec(() => ({ count: 0 }));\nconst doubled = exec((state) => state.count * 2, counter.reactive);","react-integration#React Integration":"Seamless integration with React components using hooks and providers.\nimport { useResolves, ScopeProvider } from '@pumped-fn/react';\nfunction App() {\n  const [greeting, count] = useResolves(greeting, counter);\n  return <div>{greeting} - Count: {count.count}</div>;\n}","quick-start#Quick Start":"Get started in minutes with our comprehensive guides:\nInstallation - Setup and installation\nQuick Start - Your first Pumped Functions app\nCore Concepts - Understanding executors and scopes\nReact Integration - Using with React applications","package-overview#Package Overview":"Package\tDescription\tVersion\t@pumped-fn/core-next\tCore library with executors and scopes\t\t@pumped-fn/react\tReact bindings and hooks\t\t@pumped-fn/extra\tAdditional full-stack utilities","community--support#Community & Support":"GitHub: pumped-fn/pumped-fn\nIssues: Report bugs and feature requests\nDiscussions: Community discussions","next-steps#Next Steps":"Ready to dive in? Start with our installation guide or explore core concepts to understand the fundamentals."}},"/testing/interactive-testing":{"title":"Interactive Testing","data":{"":"Interactive testing focuses on testing user interactions, complex workflows, and real-world scenarios. This guide covers testing strategies for user interactions, multi-step workflows, and integration scenarios.","user-interaction-testing#User Interaction Testing":"","basic-user-events#Basic User Events":"Test simple user interactions:\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { exec } from '@pumped-fn/core-next';\nimport { ScopeProvider } from '@pumped-fn/react';\nfunction LoginForm() {\n  const [authState] = useResolves(authStateExecutor);\n  const updateAuth = useUpdate(authStateExecutor);\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    const formData = new FormData(e.target as HTMLFormElement);\n    const email = formData.get('email') as string;\n    const password = formData.get('password') as string;\n    \n    updateAuth({ email, password, status: 'authenticating' });\n  };\n  return (\n    <form onSubmit={handleSubmit}>\n      <input name=\"email\" type=\"email\" placeholder=\"Email\" />\n      <input name=\"password\" type=\"password\" placeholder=\"Password\" />\n      <button type=\"submit\">Login</button>\n      {authState.status === 'authenticating' && <p>Logging in...</p>}\n    </form>\n  );\n}\ndescribe('LoginForm', () => {\n  it('should handle user login flow', async () => {\n    const user = userEvent.setup();\n    const authStateExecutor = exec(() => ({\n      email: '',\n      password: '',\n      status: 'idle',\n    }));\n    render(\n      <ScopeProvider>\n        <LoginForm />\n      </ScopeProvider>\n    );\n    // User types email\n    await user.type(screen.getByPlaceholderText('Email'), 'user@example.com');\n    \n    // User types password\n    await user.type(screen.getByPlaceholderText('Password'), 'password123');\n    \n    // User clicks login\n    await user.click(screen.getByRole('button', { name: 'Login' }));\n    \n    // Should show loading state\n    expect(screen.getByText('Logging in...')).toBeInTheDocument();\n  });\n});","complex-form-interactions#Complex Form Interactions":"Test multi-step forms and validation:\nfunction UserRegistrationForm() {\n  const [formData] = useResolves(formDataExecutor);\n  const [validation] = useResolves(validationExecutor);\n  const updateForm = useUpdate(formDataExecutor);\n  const handleFieldChange = (field: string, value: string) => {\n    updateForm(current => ({ ...current, [field]: value }));\n  };\n  return (\n    <form>\n      <div>\n        <input\n          name=\"firstName\"\n          placeholder=\"First Name\"\n          value={formData.firstName}\n          onChange={(e) => handleFieldChange('firstName', e.target.value)}\n        />\n        {validation.firstName && (\n          <span className=\"error\">{validation.firstName}</span>\n        )}\n      </div>\n      \n      <div>\n        <input\n          name=\"email\"\n          type=\"email\"\n          placeholder=\"Email\"\n          value={formData.email}\n          onChange={(e) => handleFieldChange('email', e.target.value)}\n        />\n        {validation.email && (\n          <span className=\"error\">{validation.email}</span>\n        )}\n      </div>\n      \n      <div>\n        <input\n          name=\"password\"\n          type=\"password\"\n          placeholder=\"Password\"\n          value={formData.password}\n          onChange={(e) => handleFieldChange('password', e.target.value)}\n        />\n        {validation.password && (\n          <span className=\"error\">{validation.password}</span>\n        )}\n      </div>\n      \n      <button type=\"submit\" disabled={!validation.isValid}>\n        Register\n      </button>\n    </form>\n  );\n}\ndescribe('UserRegistrationForm', () => {\n  it('should validate form fields as user types', async () => {\n    const user = userEvent.setup();\n    \n    const formDataExecutor = exec(() => ({\n      firstName: '',\n      email: '',\n      password: '',\n    }));\n    const validationExecutor = exec(\n      (data) => {\n        const errors: any = {};\n        \n        if (!data.firstName) errors.firstName = 'First name is required';\n        if (!data.email) errors.email = 'Email is required';\n        else if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(data.email)) {\n          errors.email = 'Invalid email format';\n        }\n        if (!data.password) errors.password = 'Password is required';\n        else if (data.password.length < 8) {\n          errors.password = 'Password must be at least 8 characters';\n        }\n        \n        return {\n          ...errors,\n          isValid: Object.keys(errors).length === 0,\n        };\n      },\n      formDataExecutor.reactive\n    );\n    render(\n      <ScopeProvider>\n        <UserRegistrationForm />\n      </ScopeProvider>\n    );\n    // Initially, submit should be disabled\n    expect(screen.getByRole('button', { name: 'Register' })).toBeDisabled();\n    // Type invalid email\n    await user.type(screen.getByPlaceholderText('Email'), 'invalid-email');\n    expect(screen.getByText('Invalid email format')).toBeInTheDocument();\n    // Type short password\n    await user.type(screen.getByPlaceholderText('Password'), 'short');\n    expect(screen.getByText('Password must be at least 8 characters')).toBeInTheDocument();\n    // Fill in valid data\n    await user.type(screen.getByPlaceholderText('First Name'), 'John');\n    await user.clear(screen.getByPlaceholderText('Email'));\n    await user.type(screen.getByPlaceholderText('Email'), 'john@example.com');\n    await user.clear(screen.getByPlaceholderText('Password'));\n    await user.type(screen.getByPlaceholderText('Password'), 'password123');\n    // Submit should now be enabled\n    expect(screen.getByRole('button', { name: 'Register' })).not.toBeDisabled();\n  });\n});","multi-step-workflows#Multi-Step Workflows":"","wizardstepper-components#Wizard/Stepper Components":"Test multi-step workflows:\nfunction RegistrationWizard() {\n  const [currentStep] = useResolves(currentStepExecutor);\n  const [wizardData] = useResolves(wizardDataExecutor);\n  const updateStep = useUpdate(currentStepExecutor);\n  const updateData = useUpdate(wizardDataExecutor);\n  const nextStep = () => {\n    updateStep(current => Math.min(current + 1, 3));\n  };\n  const prevStep = () => {\n    updateStep(current => Math.max(current - 1, 1));\n  };\n  return (\n    <div>\n      <div className=\"step-indicator\">\n        Step {currentStep} of 3\n      </div>\n      \n      {currentStep === 1 && (\n        <PersonalInfoStep \n          data={wizardData.personalInfo}\n          onUpdate={(data) => updateData(current => ({ \n            ...current, \n            personalInfo: data \n          }))}\n        />\n      )}\n      \n      {currentStep === 2 && (\n        <ContactInfoStep \n          data={wizardData.contactInfo}\n          onUpdate={(data) => updateData(current => ({ \n            ...current, \n            contactInfo: data \n          }))}\n        />\n      )}\n      \n      {currentStep === 3 && (\n        <ReviewStep data={wizardData} />\n      )}\n      \n      <div className=\"navigation\">\n        {currentStep > 1 && (\n          <button onClick={prevStep}>Previous</button>\n        )}\n        {currentStep < 3 && (\n          <button onClick={nextStep}>Next</button>\n        )}\n        {currentStep === 3 && (\n          <button onClick={() => console.log('Submit')}>Submit</button>\n        )}\n      </div>\n    </div>\n  );\n}\ndescribe('RegistrationWizard', () => {\n  it('should navigate through wizard steps', async () => {\n    const user = userEvent.setup();\n    \n    const currentStepExecutor = exec(() => 1);\n    const wizardDataExecutor = exec(() => ({\n      personalInfo: { firstName: '', lastName: '' },\n      contactInfo: { email: '', phone: '' },\n    }));\n    render(\n      <ScopeProvider>\n        <RegistrationWizard />\n      </ScopeProvider>\n    );\n    // Should start at step 1\n    expect(screen.getByText('Step 1 of 3')).toBeInTheDocument();\n    \n    // Should show personal info step\n    expect(screen.getByText('Personal Information')).toBeInTheDocument();\n    \n    // Click next\n    await user.click(screen.getByText('Next'));\n    \n    // Should move to step 2\n    expect(screen.getByText('Step 2 of 3')).toBeInTheDocument();\n    expect(screen.getByText('Contact Information')).toBeInTheDocument();\n    \n    // Click next again\n    await user.click(screen.getByText('Next'));\n    \n    // Should move to step 3\n    expect(screen.getByText('Step 3 of 3')).toBeInTheDocument();\n    expect(screen.getByText('Review')).toBeInTheDocument();\n    \n    // Should show submit button\n    expect(screen.getByText('Submit')).toBeInTheDocument();\n    \n    // Click previous\n    await user.click(screen.getByText('Previous'));\n    \n    // Should go back to step 2\n    expect(screen.getByText('Step 2 of 3')).toBeInTheDocument();\n  });\n});","shopping-cart-workflow#Shopping Cart Workflow":"Test e-commerce workflows:\nfunction ShoppingCart() {\n  const [cart] = useResolves(cartExecutor);\n  const [products] = useResolves(productsExecutor);\n  const updateCart = useUpdate(cartExecutor);\n  const addToCart = (product: Product) => {\n    updateCart(current => ({\n      ...current,\n      items: [...current.items, { ...product, quantity: 1 }],\n    }));\n  };\n  const removeFromCart = (productId: string) => {\n    updateCart(current => ({\n      ...current,\n      items: current.items.filter(item => item.id !== productId),\n    }));\n  };\n  const updateQuantity = (productId: string, quantity: number) => {\n    updateCart(current => ({\n      ...current,\n      items: current.items.map(item =>\n        item.id === productId ? { ...item, quantity } : item\n      ),\n    }));\n  };\n  return (\n    <div>\n      <div className=\"products\">\n        {products.map(product => (\n          <div key={product.id} className=\"product\">\n            <h3>{product.name}</h3>\n            <p>${product.price}</p>\n            <button onClick={() => addToCart(product)}>\n              Add to Cart\n            </button>\n          </div>\n        ))}\n      </div>\n      \n      <div className=\"cart\">\n        <h2>Cart ({cart.items.length})</h2>\n        {cart.items.map(item => (\n          <div key={item.id} className=\"cart-item\">\n            <span>{item.name}</span>\n            <input\n              type=\"number\"\n              value={item.quantity}\n              onChange={(e) => updateQuantity(item.id, parseInt(e.target.value))}\n            />\n            <button onClick={() => removeFromCart(item.id)}>\n              Remove\n            </button>\n          </div>\n        ))}\n        <div className=\"total\">\n          Total: ${cart.items.reduce((sum, item) => sum + item.price * item.quantity, 0)}\n        </div>\n      </div>\n    </div>\n  );\n}\ndescribe('ShoppingCart', () => {\n  it('should handle complete shopping workflow', async () => {\n    const user = userEvent.setup();\n    \n    const productsExecutor = exec(() => [\n      { id: '1', name: 'Laptop', price: 999 },\n      { id: '2', name: 'Mouse', price: 25 },\n    ]);\n    const cartExecutor = exec(() => ({\n      items: [],\n      total: 0,\n    }));\n    render(\n      <ScopeProvider>\n        <ShoppingCart />\n      </ScopeProvider>\n    );\n    // Initially empty cart\n    expect(screen.getByText('Cart (0)')).toBeInTheDocument();\n    expect(screen.getByText('Total: $0')).toBeInTheDocument();\n    // Add laptop to cart\n    await user.click(screen.getByText('Add to Cart'));\n    expect(screen.getByText('Cart (1)')).toBeInTheDocument();\n    expect(screen.getByText('Total: $999')).toBeInTheDocument();\n    // Add mouse to cart\n    const addButtons = screen.getAllByText('Add to Cart');\n    await user.click(addButtons[1]);\n    expect(screen.getByText('Cart (2)')).toBeInTheDocument();\n    expect(screen.getByText('Total: $1024')).toBeInTheDocument();\n    // Update laptop quantity\n    const quantityInput = screen.getByDisplayValue('1');\n    await user.clear(quantityInput);\n    await user.type(quantityInput, '2');\n    expect(screen.getByText('Total: $2023')).toBeInTheDocument();\n    // Remove mouse from cart\n    const removeButtons = screen.getAllByText('Remove');\n    await user.click(removeButtons[1]);\n    expect(screen.getByText('Cart (1)')).toBeInTheDocument();\n    expect(screen.getByText('Total: $1998')).toBeInTheDocument();\n  });\n});","real-time-updates#Real-Time Updates":"","websocket-integration#WebSocket Integration":"Test real-time updates:\nfunction ChatRoom() {\n  const [messages] = useResolves(messagesExecutor);\n  const [currentUser] = useResolves(currentUserExecutor);\n  const updateMessages = useUpdate(messagesExecutor);\n  const sendMessage = (text: string) => {\n    const newMessage = {\n      id: Date.now().toString(),\n      text,\n      author: currentUser.name,\n      timestamp: new Date(),\n    };\n    \n    updateMessages(current => [...current, newMessage]);\n  };\n  return (\n    <div>\n      <div className=\"messages\">\n        {messages.map(message => (\n          <div key={message.id} className=\"message\">\n            <strong>{message.author}:</strong> {message.text}\n          </div>\n        ))}\n      </div>\n      \n      <MessageInput onSend={sendMessage} />\n    </div>\n  );\n}\ndescribe('ChatRoom', () => {\n  it('should handle real-time message updates', async () => {\n    const user = userEvent.setup();\n    \n    const messagesExecutor = exec(() => [\n      { id: '1', text: 'Hello!', author: 'Alice', timestamp: new Date() },\n    ]);\n    const currentUserExecutor = exec(() => ({\n      name: 'Bob',\n      id: '2',\n    }));\n    const { scope } = renderWithScope(<ChatRoom />);\n    // Should show existing message\n    expect(screen.getByText('Alice: Hello!')).toBeInTheDocument();\n    // Send new message\n    await user.type(screen.getByPlaceholderText('Type a message...'), 'Hi there!');\n    await user.click(screen.getByText('Send'));\n    // Should show new message\n    expect(screen.getByText('Bob: Hi there!')).toBeInTheDocument();\n    // Simulate receiving message from another user\n    scope.update(messagesExecutor, current => [\n      ...current,\n      { id: '3', text: 'How are you?', author: 'Charlie', timestamp: new Date() },\n    ]);\n    expect(screen.getByText('Charlie: How are you?')).toBeInTheDocument();\n  });\n});","integration-testing#Integration Testing":"","full-application-flow#Full Application Flow":"Test complete user journeys:\nfunction App() {\n  return (\n    <ScopeProvider>\n      <Router>\n        <Routes>\n          <Route path=\"/\" element={<Home />} />\n          <Route path=\"/login\" element={<Login />} />\n          <Route path=\"/dashboard\" element={<Dashboard />} />\n          <Route path=\"/profile\" element={<Profile />} />\n        </Routes>\n      </Router>\n    </ScopeProvider>\n  );\n}\ndescribe('App Integration', () => {\n  it('should handle complete user authentication flow', async () => {\n    const user = userEvent.setup();\n    \n    render(<App />);\n    // Start at home page\n    expect(screen.getByText('Welcome')).toBeInTheDocument();\n    // Click login\n    await user.click(screen.getByText('Login'));\n    \n    // Should navigate to login page\n    expect(screen.getByText('Sign In')).toBeInTheDocument();\n    // Fill in credentials\n    await user.type(screen.getByPlaceholderText('Email'), 'user@example.com');\n    await user.type(screen.getByPlaceholderText('Password'), 'password123');\n    \n    // Submit form\n    await user.click(screen.getByRole('button', { name: 'Sign In' }));\n    // Should navigate to dashboard\n    await waitFor(() => {\n      expect(screen.getByText('Dashboard')).toBeInTheDocument();\n    });\n    // Click profile\n    await user.click(screen.getByText('Profile'));\n    \n    // Should show profile page\n    expect(screen.getByText('User Profile')).toBeInTheDocument();\n  });\n});","api-integration#API Integration":"Test API interactions:\nfunction UserManagement() {\n  const [users] = useResolves(usersExecutor);\n  const [loading] = useResolves(loadingExecutor);\n  const updateUsers = useUpdate(usersExecutor);\n  const updateLoading = useUpdate(loadingExecutor);\n  const loadUsers = async () => {\n    updateLoading(true);\n    try {\n      const response = await fetch('/api/users');\n      const users = await response.json();\n      updateUsers(users);\n    } finally {\n      updateLoading(false);\n    }\n  };\n  const createUser = async (userData: any) => {\n    updateLoading(true);\n    try {\n      const response = await fetch('/api/users', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(userData),\n      });\n      const newUser = await response.json();\n      updateUsers(current => [...current, newUser]);\n    } finally {\n      updateLoading(false);\n    }\n  };\n  return (\n    <div>\n      <button onClick={loadUsers}>Load Users</button>\n      <CreateUserForm onSubmit={createUser} />\n      \n      {loading && <p>Loading...</p>}\n      \n      <div className=\"users\">\n        {users.map(user => (\n          <div key={user.id} className=\"user\">\n            {user.name} ({user.email})\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\ndescribe('UserManagement API Integration', () => {\n  beforeEach(() => {\n    // Setup MSW or similar for API mocking\n    server.use(\n      rest.get('/api/users', (req, res, ctx) => {\n        return res(ctx.json([\n          { id: 1, name: 'John', email: 'john@example.com' },\n          { id: 2, name: 'Jane', email: 'jane@example.com' },\n        ]));\n      }),\n      rest.post('/api/users', (req, res, ctx) => {\n        return res(ctx.json({ id: 3, ...req.body }));\n      })\n    );\n  });\n  it('should load and create users', async () => {\n    const user = userEvent.setup();\n    \n    const usersExecutor = exec(() => []);\n    const loadingExecutor = exec(() => false);\n    render(\n      <ScopeProvider>\n        <UserManagement />\n      </ScopeProvider>\n    );\n    // Load users\n    await user.click(screen.getByText('Load Users'));\n    \n    // Should show loading\n    expect(screen.getByText('Loading...')).toBeInTheDocument();\n    \n    // Should load users\n    await waitFor(() => {\n      expect(screen.getByText('John (john@example.com)')).toBeInTheDocument();\n      expect(screen.getByText('Jane (jane@example.com)')).toBeInTheDocument();\n    });\n    // Create new user\n    await user.type(screen.getByPlaceholderText('Name'), 'Bob');\n    await user.type(screen.getByPlaceholderText('Email'), 'bob@example.com');\n    await user.click(screen.getByText('Create User'));\n    // Should show new user\n    await waitFor(() => {\n      expect(screen.getByText('Bob (bob@example.com)')).toBeInTheDocument();\n    });\n  });\n});","performance-testing#Performance Testing":"","interaction-performance#Interaction Performance":"Test performance of user interactions:\ndescribe('Performance', () => {\n  it('should handle rapid user interactions efficiently', async () => {\n    const user = userEvent.setup();\n    \n    const counterExecutor = exec(() => ({ count: 0 }));\n    \n    render(\n      <ScopeProvider>\n        <Counter />\n      </ScopeProvider>\n    );\n    const incrementButton = screen.getByText('Increment');\n    \n    // Measure performance of rapid clicks\n    const start = performance.now();\n    \n    // Rapidly click 100 times\n    for (let i = 0; i < 100; i++) {\n      await user.click(incrementButton);\n    }\n    \n    const end = performance.now();\n    const duration = end - start;\n    \n    // Should handle 100 clicks in reasonable time\n    expect(duration).toBeLessThan(1000); // Less than 1 second\n    expect(screen.getByText('Count: 100')).toBeInTheDocument();\n  });\n});","error-handling#Error Handling":"","user-error-scenarios#User Error Scenarios":"Test error handling in user workflows:\nfunction FileUpload() {\n  const [uploadState] = useResolves(uploadStateExecutor);\n  const updateUpload = useUpdate(uploadStateExecutor);\n  const handleFileUpload = async (file: File) => {\n    updateUpload({ status: 'uploading', error: null });\n    \n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n      \n      const response = await fetch('/api/upload', {\n        method: 'POST',\n        body: formData,\n      });\n      \n      if (!response.ok) {\n        throw new Error('Upload failed');\n      }\n      \n      const result = await response.json();\n      updateUpload({ status: 'success', result, error: null });\n    } catch (error) {\n      updateUpload({ status: 'error', error: error.message });\n    }\n  };\n  return (\n    <div>\n      <input\n        type=\"file\"\n        onChange={(e) => {\n          const file = e.target.files?.[0];\n          if (file) handleFileUpload(file);\n        }}\n      />\n      \n      {uploadState.status === 'uploading' && <p>Uploading...</p>}\n      {uploadState.status === 'success' && <p>Upload successful!</p>}\n      {uploadState.status === 'error' && (\n        <p className=\"error\">Error: {uploadState.error}</p>\n      )}\n    </div>\n  );\n}\ndescribe('FileUpload Error Handling', () => {\n  it('should handle upload errors gracefully', async () => {\n    const user = userEvent.setup();\n    \n    // Mock failed upload\n    server.use(\n      rest.post('/api/upload', (req, res, ctx) => {\n        return res(ctx.status(500), ctx.json({ error: 'Server error' }));\n      })\n    );\n    const uploadStateExecutor = exec(() => ({\n      status: 'idle',\n      error: null,\n      result: null,\n    }));\n    render(\n      <ScopeProvider>\n        <FileUpload />\n      </ScopeProvider>\n    );\n    // Create a test file\n    const file = new File(['test content'], 'test.txt', { type: 'text/plain' });\n    \n    // Upload file\n    const fileInput = screen.getByLabelText('file');\n    await user.upload(fileInput, file);\n    // Should show uploading state\n    expect(screen.getByText('Uploading...')).toBeInTheDocument();\n    // Should show error message\n    await waitFor(() => {\n      expect(screen.getByText('Error: Upload failed')).toBeInTheDocument();\n    });\n  });\n});","best-practices#Best Practices":"","1-test-user-journeys#1. Test User Journeys":"Focus on complete user workflows:\ndescribe('User Registration Journey', () => {\n  it('should handle complete registration flow', async () => {\n    // Test the entire flow from start to finish\n    const user = userEvent.setup();\n    \n    render(<App />);\n    \n    // Navigate to registration\n    await user.click(screen.getByText('Sign Up'));\n    \n    // Fill registration form\n    await user.type(screen.getByPlaceholderText('Name'), 'John Doe');\n    await user.type(screen.getByPlaceholderText('Email'), 'john@example.com');\n    await user.type(screen.getByPlaceholderText('Password'), 'password123');\n    \n    // Submit form\n    await user.click(screen.getByText('Register'));\n    \n    // Verify success\n    await waitFor(() => {\n      expect(screen.getByText('Registration successful!')).toBeInTheDocument();\n    });\n  });\n});","2-test-error-scenarios#2. Test Error Scenarios":"Don't forget to test error cases:\ndescribe('Error Scenarios', () => {\n  it('should handle network errors', async () => {\n    // Mock network failure\n    server.use(\n      rest.post('/api/login', (req, res, ctx) => {\n        return res.networkError('Network error');\n      })\n    );\n    // Test error handling\n    const user = userEvent.setup();\n    render(<LoginForm />);\n    \n    await user.type(screen.getByPlaceholderText('Email'), 'test@example.com');\n    await user.type(screen.getByPlaceholderText('Password'), 'password');\n    await user.click(screen.getByText('Login'));\n    \n    await waitFor(() => {\n      expect(screen.getByText('Network error occurred')).toBeInTheDocument();\n    });\n  });\n});","3-test-accessibility#3. Test Accessibility":"Include accessibility testing:\nimport { axe, toHaveNoViolations } from 'jest-axe';\nexpect.extend(toHaveNoViolations);\ndescribe('Accessibility', () => {\n  it('should have no accessibility violations', async () => {\n    const { container } = render(<App />);\n    const results = await axe(container);\n    expect(results).toHaveNoViolations();\n  });\n});","next-steps#Next Steps":"Testing Overview - Back to testing overview\nTesting Executors - Executor-specific testing\nTesting React Components - Component testing patterns\nInteractive testing ensures your application works correctly in real-world scenarios. By testing complete user workflows, you can catch integration issues and ensure a smooth user experience."}},"/testing/testing-executors":{"title":"Testing Executors","data":{"":"Testing executors is straightforward because they are pure functions with explicit dependencies. This guide covers comprehensive testing strategies for all types of executors.","basic-executor-testing#Basic Executor Testing":"","simple-executors#Simple Executors":"Test executors with no dependencies:\nimport { describe, it, expect } from 'vitest';\nimport { exec, createScope } from '@pumped-fn/core-next';\ndescribe('Simple Executors', () => {\n  it('should return constant value', () => {\n    const greeting = exec(() => 'Hello, World!');\n    \n    const scope = createScope();\n    const result = scope.resolve(greeting);\n    \n    expect(result).toBe('Hello, World!');\n  });\n  it('should compute value', () => {\n    const currentTime = exec(() => new Date('2023-01-01'));\n    \n    const scope = createScope();\n    const result = scope.resolve(currentTime);\n    \n    expect(result).toEqual(new Date('2023-01-01'));\n  });\n});","executors-with-dependencies#Executors with Dependencies":"Test executors that depend on other executors:\ndescribe('Dependent Executors', () => {\n  it('should combine values from dependencies', () => {\n    const firstName = exec(() => 'John');\n    const lastName = exec(() => 'Doe');\n    \n    const fullName = exec(\n      (first: string, last: string) => `${first} ${last}`,\n      [firstName, lastName]\n    );\n    const scope = createScope();\n    const result = scope.resolve(fullName);\n    \n    expect(result).toBe('John Doe');\n  });\n  it('should handle object dependencies', () => {\n    const user = exec(() => ({ name: 'John', age: 30 }));\n    const preferences = exec(() => ({ theme: 'dark', lang: 'en' }));\n    \n    const profile = exec(\n      ({ user, prefs }) => ({ ...user, preferences: prefs }),\n      { user, prefs: preferences }\n    );\n    const scope = createScope();\n    const result = scope.resolve(profile);\n    \n    expect(result).toEqual({\n      name: 'John',\n      age: 30,\n      preferences: { theme: 'dark', lang: 'en' }\n    });\n  });\n});","testing-async-executors#Testing Async Executors":"","basic-async-testing#Basic Async Testing":"describe('Async Executors', () => {\n  it('should resolve async values', async () => {\n    const asyncData = exec(async () => {\n      await new Promise(resolve => setTimeout(resolve, 10));\n      return { data: 'async result' };\n    });\n    const scope = createScope();\n    const result = await scope.resolve(asyncData);\n    expect(result.data).toBe('async result');\n  });\n  it('should handle async dependencies', async () => {\n    const asyncUser = exec(async () => {\n      await new Promise(resolve => setTimeout(resolve, 5));\n      return { id: 1, name: 'John' };\n    });\n    const userProfile = exec(\n      async (user) => ({\n        ...user,\n        displayName: `User: ${user.name}`,\n      }),\n      asyncUser\n    );\n    const scope = createScope();\n    const result = await scope.resolve(userProfile);\n    expect(result).toEqual({\n      id: 1,\n      name: 'John',\n      displayName: 'User: John'\n    });\n  });\n});","error-handling#Error Handling":"describe('Error Handling', () => {\n  it('should propagate errors from executors', async () => {\n    const failingExecutor = exec(async () => {\n      throw new Error('Network error');\n    });\n    const scope = createScope();\n    \n    await expect(scope.resolve(failingExecutor))\n      .rejects\n      .toThrow('Network error');\n  });\n  it('should handle errors in dependency chain', async () => {\n    const failingDep = exec(() => {\n      throw new Error('Dependency failed');\n    });\n    const dependentExecutor = exec(\n      (value: any) => `Processed: ${value}`,\n      failingDep\n    );\n    const scope = createScope();\n    \n    expect(() => scope.resolve(dependentExecutor))\n      .toThrow('Dependency failed');\n  });\n});","testing-reactive-executors#Testing Reactive Executors":"","reactive-updates#Reactive Updates":"Test how reactive executors respond to changes:\ndescribe('Reactive Executors', () => {\n  it('should update when dependency changes', () => {\n    const counter = exec(() => ({ count: 0 }));\n    const doubled = exec(\n      (state) => state.count * 2,\n      counter.reactive\n    );\n    const scope = createScope();\n    \n    // Initial state\n    expect(scope.resolve(doubled)).toBe(0);\n    \n    // Update dependency\n    scope.update(counter, { count: 5 });\n    \n    // Reactive executor should update\n    expect(scope.resolve(doubled)).toBe(10);\n  });\n  it('should handle multiple reactive dependencies', () => {\n    const a = exec(() => 10);\n    const b = exec(() => 20);\n    \n    const sum = exec(\n      (a: number, b: number) => a + b,\n      [a.reactive, b.reactive]\n    );\n    const scope = createScope();\n    \n    // Initial sum\n    expect(scope.resolve(sum)).toBe(30);\n    \n    // Update first dependency\n    scope.update(a, 15);\n    expect(scope.resolve(sum)).toBe(35);\n    \n    // Update second dependency\n    scope.update(b, 25);\n    expect(scope.resolve(sum)).toBe(40);\n  });\n});","reactive-chains#Reactive Chains":"Test complex reactive dependency chains:\ndescribe('Reactive Chains', () => {\n  it('should propagate changes through chain', () => {\n    const base = exec(() => 10);\n    const doubled = exec((n: number) => n * 2, base.reactive);\n    const squared = exec((n: number) => n * n, doubled.reactive);\n    const scope = createScope();\n    \n    // Initial: 10 -> 20 -> 400\n    expect(scope.resolve(squared)).toBe(400);\n    \n    // Update base: 5 -> 10 -> 100\n    scope.update(base, 5);\n    expect(scope.resolve(squared)).toBe(100);\n  });\n});","testing-lazy-executors#Testing Lazy Executors":"","lazy-resolution#Lazy Resolution":"Test that lazy executors only resolve when needed:\ndescribe('Lazy Executors', () => {\n  it('should only resolve when accessed', () => {\n    let resolveCount = 0;\n    \n    const expensiveExecutor = exec(() => {\n      resolveCount++;\n      return 'expensive result';\n    });\n    const conditionalExecutor = exec(\n      (condition: boolean, value: string) => condition ? value : null,\n      [exec(() => false), expensiveExecutor.lazy]\n    );\n    const scope = createScope();\n    const result = scope.resolve(conditionalExecutor);\n    expect(result).toBe(null);\n    expect(resolveCount).toBe(0); // Should not have resolved\n  });\n  it('should resolve when actually needed', () => {\n    let resolveCount = 0;\n    \n    const expensiveExecutor = exec(() => {\n      resolveCount++;\n      return 'expensive result';\n    });\n    const conditionalExecutor = exec(\n      (condition: boolean, value: string) => condition ? value : null,\n      [exec(() => true), expensiveExecutor.lazy]\n    );\n    const scope = createScope();\n    const result = scope.resolve(conditionalExecutor);\n    expect(result).toBe('expensive result');\n    expect(resolveCount).toBe(1); // Should have resolved once\n  });\n});","testing-static-executors#Testing Static Executors":"","caching-behavior#Caching Behavior":"Test that static executors cache their results:\ndescribe('Static Executors', () => {\n  it('should cache results', () => {\n    let callCount = 0;\n    \n    const cachedExecutor = exec(() => {\n      callCount++;\n      return Math.random();\n    });\n    const scope = createScope();\n    \n    const result1 = scope.resolve(cachedExecutor);\n    const result2 = scope.resolve(cachedExecutor);\n    \n    expect(result1).toBe(result2);\n    expect(callCount).toBe(1);\n  });\n  it('should cache across different scopes', () => {\n    let callCount = 0;\n    \n    const globalExecutor = exec(() => {\n      callCount++;\n      return 'global value';\n    });\n    const scope1 = createScope();\n    const scope2 = createScope();\n    \n    const result1 = scope1.resolve(globalExecutor);\n    const result2 = scope2.resolve(globalExecutor);\n    \n    expect(result1).toBe('global value');\n    expect(result2).toBe('global value');\n    expect(callCount).toBe(1);\n  });\n});","mocking-dependencies#Mocking Dependencies":"","simple-mocking#Simple Mocking":"Replace dependencies with mock values:\ndescribe('Mocking Dependencies', () => {\n  it('should work with mock dependencies', () => {\n    // Mock dependency\n    const mockApiClient = exec(() => ({\n      get: (url: string) => Promise.resolve({ data: 'mocked' })\n    }));\n    const dataService = exec(\n      (api) => ({\n        fetchData: (url: string) => api.get(url)\n      }),\n      mockApiClient\n    );\n    const scope = createScope();\n    const service = scope.resolve(dataService);\n    expect(service.fetchData).toBeDefined();\n  });\n});","using-vitest-mocks#Using Vitest Mocks":"Integrate with Vitest's mocking capabilities:\nimport { vi } from 'vitest';\ndescribe('Service with Mocks', () => {\n  it('should use mocked methods', async () => {\n    const mockApi = {\n      getUser: vi.fn().mockResolvedValue({ id: 1, name: 'John' }),\n      updateUser: vi.fn().mockResolvedValue({ success: true })\n    };\n    const apiExecutor = exec(() => mockApi);\n    \n    const userService = exec(\n      (api) => ({\n        getUser: (id: number) => api.getUser(id),\n        updateUser: (id: number, data: any) => api.updateUser(id, data)\n      }),\n      apiExecutor\n    );\n    const scope = createScope();\n    const service = scope.resolve(userService);\n    const user = await service.getUser(1);\n    expect(user).toEqual({ id: 1, name: 'John' });\n    expect(mockApi.getUser).toHaveBeenCalledWith(1);\n  });\n});","testing-complex-scenarios#Testing Complex Scenarios":"","state-management#State Management":"Test state management patterns:\ndescribe('State Management', () => {\n  it('should handle complex state updates', () => {\n    const initialState = exec(() => ({\n      users: [],\n      currentUser: null,\n      loading: false\n    }));\n    const addUser = exec(\n      (user: User) => (state: AppState) => ({\n        ...state,\n        users: [...state.users, user]\n      }),\n      []\n    );\n    const setCurrentUser = exec(\n      (userId: string) => (state: AppState) => ({\n        ...state,\n        currentUser: state.users.find(u => u.id === userId) || null\n      }),\n      []\n    );\n    const scope = createScope();\n    \n    // Initial state\n    expect(scope.resolve(initialState)).toEqual({\n      users: [],\n      currentUser: null,\n      loading: false\n    });\n    // Add user\n    const newUser = { id: '1', name: 'John' };\n    scope.update(initialState, addUser(newUser));\n    \n    const stateAfterAdd = scope.resolve(initialState);\n    expect(stateAfterAdd.users).toHaveLength(1);\n    expect(stateAfterAdd.users[0]).toEqual(newUser);\n    // Set current user\n    scope.update(initialState, setCurrentUser('1'));\n    \n    const finalState = scope.resolve(initialState);\n    expect(finalState.currentUser).toEqual(newUser);\n  });\n});","data-transformation#Data Transformation":"Test data transformation pipelines:\ndescribe('Data Transformation', () => {\n  it('should transform data through pipeline', () => {\n    const rawData = exec(() => [\n      { name: 'john doe', age: 25, active: true },\n      { name: 'jane smith', age: 30, active: false },\n      { name: 'bob johnson', age: 35, active: true }\n    ]);\n    const normalizedData = exec(\n      (data) => data.map(user => ({\n        ...user,\n        name: user.name.split(' ').map(n => \n          n.charAt(0).toUpperCase() + n.slice(1)\n        ).join(' ')\n      })),\n      rawData\n    );\n    const activeUsers = exec(\n      (data) => data.filter(user => user.active),\n      normalizedData\n    );\n    const userStats = exec(\n      (users) => ({\n        total: users.length,\n        averageAge: users.reduce((sum, u) => sum + u.age, 0) / users.length\n      }),\n      activeUsers\n    );\n    const scope = createScope();\n    const stats = scope.resolve(userStats);\n    expect(stats.total).toBe(2);\n    expect(stats.averageAge).toBe(30);\n  });\n});","testing-best-practices#Testing Best Practices":"","1-test-one-thing-at-a-time#1. Test One Thing at a Time":"Focus each test on a single aspect:\ndescribe('UserValidator', () => {\n  it('should validate email format', () => {\n    const validator = exec(() => ({\n      isValidEmail: (email: string) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(email)\n    }));\n    const scope = createScope();\n    const { isValidEmail } = scope.resolve(validator);\n    expect(isValidEmail('test@example.com')).toBe(true);\n    expect(isValidEmail('invalid-email')).toBe(false);\n  });\n  it('should validate password strength', () => {\n    const validator = exec(() => ({\n      isStrongPassword: (password: string) => password.length >= 8\n    }));\n    const scope = createScope();\n    const { isStrongPassword } = scope.resolve(validator);\n    expect(isStrongPassword('strongpassword')).toBe(true);\n    expect(isStrongPassword('weak')).toBe(false);\n  });\n});","2-use-descriptive-test-names#2. Use Descriptive Test Names":"Make tests self-documenting:\ndescribe('Calculator', () => {\n  it('should return 0 when given empty array', () => {\n    // Test implementation\n  });\n  it('should sum positive numbers correctly', () => {\n    // Test implementation\n  });\n  it('should handle negative numbers', () => {\n    // Test implementation\n  });\n  it('should throw error for non-numeric values', () => {\n    // Test implementation\n  });\n});","3-use-test-utilities#3. Use Test Utilities":"Create reusable test utilities:\n// test/executors.ts\nexport function createMockUser(overrides = {}) {\n  return exec(() => ({\n    id: '1',\n    name: 'Test User',\n    email: 'test@example.com',\n    ...overrides\n  }));\n}\nexport function resolveInScope<T>(executor: Executor<T>) {\n  const scope = createScope();\n  return scope.resolve(executor);\n}\n// Usage\nit('should format user name', () => {\n  const user = createMockUser({ name: 'John Doe' });\n  const result = resolveInScope(user);\n  expect(result.name).toBe('John Doe');\n});","4-test-edge-cases#4. Test Edge Cases":"Don't forget edge cases:\ndescribe('ArrayUtils', () => {\n  it('should handle empty arrays', () => {\n    const empty = exec(() => []);\n    const sum = exec((arr: number[]) => arr.reduce((a, b) => a + b, 0), empty);\n    \n    expect(resolveInScope(sum)).toBe(0);\n  });\n  it('should handle single element arrays', () => {\n    const single = exec(() => [42]);\n    const sum = exec((arr: number[]) => arr.reduce((a, b) => a + b, 0), single);\n    \n    expect(resolveInScope(sum)).toBe(42);\n  });\n  it('should handle null/undefined values', () => {\n    const nullValue = exec(() => null);\n    const defaulted = exec((val: any) => val || 'default', nullValue);\n    \n    expect(resolveInScope(defaulted)).toBe('default');\n  });\n});","performance-testing#Performance Testing":"","measuring-performance#Measuring Performance":"Test performance characteristics:\ndescribe('Performance', () => {\n  it('should resolve large dependency graphs efficiently', () => {\n    const start = performance.now();\n    \n    // Create large dependency graph\n    const executors = Array.from({ length: 1000 }, (_, i) => \n      exec(() => i)\n    );\n    \n    const combined = exec(\n      (...values: number[]) => values.reduce((sum, val) => sum + val, 0),\n      executors\n    );\n    const scope = createScope();\n    const result = scope.resolve(combined);\n    \n    const duration = performance.now() - start;\n    \n    expect(result).toBe(499500); // Sum of 0 to 999\n    expect(duration).toBeLessThan(100); // Should be reasonably fast\n  });\n});","next-steps#Next Steps":"Testing React Components - Test React components that use executors\nTesting Utilities - Advanced testing utilities and helpers\nInteractive Testing - Testing user interactions\nTesting executors is fundamental to building reliable applications with Pumped Functions. The patterns shown here will help you create comprehensive test suites that catch bugs early and document your application's behavior."}},"/testing/testing-react":{"title":"Testing React Components","data":{"":"Testing React components that use Pumped Functions is straightforward thanks to the clean separation between logic (executors) and presentation (components). This guide covers comprehensive testing strategies for React integration.","setup#Setup":"","testing-dependencies#Testing Dependencies":"pnpm add -D @testing-library/react @testing-library/jest-dom @testing-library/user-event","test-setup#Test Setup":"// vitest.config.ts\nimport { defineConfig } from 'vitest/config';\nexport default defineConfig({\n  test: {\n    environment: 'jsdom',\n    setupFiles: ['./src/test/setup.ts'],\n  },\n});\n// src/test/setup.ts\nimport '@testing-library/jest-dom';","basic-component-testing#Basic Component Testing":"","simple-component#Simple Component":"Test a component that uses useResolves:\nimport { render, screen } from '@testing-library/react';\nimport { exec } from '@pumped-fn/core-next';\nimport { ScopeProvider } from '@pumped-fn/react';\nimport { UserProfile } from './UserProfile';\n// Component under test\nfunction UserProfile() {\n  const [user] = useResolves(userExecutor);\n  \n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  );\n}\n// Test\ndescribe('UserProfile', () => {\n  it('should render user information', () => {\n    const userExecutor = exec(() => ({\n      name: 'John Doe',\n      email: 'john@example.com'\n    }));\n    render(\n      <ScopeProvider>\n        <UserProfile />\n      </ScopeProvider>\n    );\n    expect(screen.getByText('John Doe')).toBeInTheDocument();\n    expect(screen.getByText('john@example.com')).toBeInTheDocument();\n  });\n});","component-with-multiple-executors#Component with Multiple Executors":"import { render, screen } from '@testing-library/react';\nimport { exec } from '@pumped-fn/core-next';\nimport { ScopeProvider } from '@pumped-fn/react';\nfunction Dashboard() {\n  const [user, notifications, settings] = useResolves(\n    userExecutor,\n    notificationsExecutor,\n    settingsExecutor\n  );\n  return (\n    <div>\n      <h1>Welcome {user.name}!</h1>\n      <p>You have {notifications.length} notifications</p>\n      <p>Theme: {settings.theme}</p>\n    </div>\n  );\n}\ndescribe('Dashboard', () => {\n  it('should render all data correctly', () => {\n    const userExecutor = exec(() => ({ name: 'John' }));\n    const notificationsExecutor = exec(() => [\n      { id: 1, message: 'Hello' },\n      { id: 2, message: 'World' }\n    ]);\n    const settingsExecutor = exec(() => ({ theme: 'dark' }));\n    render(\n      <ScopeProvider>\n        <Dashboard />\n      </ScopeProvider>\n    );\n    expect(screen.getByText('Welcome John!')).toBeInTheDocument();\n    expect(screen.getByText('You have 2 notifications')).toBeInTheDocument();\n    expect(screen.getByText('Theme: dark')).toBeInTheDocument();\n  });\n});","testing-with-custom-scopes#Testing with Custom Scopes":"","pre-populated-scope#Pre-populated Scope":"Test components with pre-set data:\nimport { createScope } from '@pumped-fn/core-next';\nimport { ScopeProvider } from '@pumped-fn/react';\ndescribe('UserProfile with preset data', () => {\n  it('should use preset user data', () => {\n    const scope = createScope();\n    const testUser = { name: 'Test User', email: 'test@example.com' };\n    \n    // Pre-populate the scope\n    scope.update(userExecutor, testUser);\n    render(\n      <ScopeProvider scope={scope}>\n        <UserProfile />\n      </ScopeProvider>\n    );\n    expect(screen.getByText('Test User')).toBeInTheDocument();\n    expect(screen.getByText('test@example.com')).toBeInTheDocument();\n  });\n});","scope-with-presets#Scope with Presets":"describe('Dashboard with presets', () => {\n  it('should use preset values', () => {\n    const presets = [\n      { executor: userExecutor, value: { name: 'Preset User' } },\n      { executor: settingsExecutor, value: { theme: 'light' } }\n    ];\n    render(\n      <ScopeProvider presets={presets}>\n        <Dashboard />\n      </ScopeProvider>\n    );\n    expect(screen.getByText('Welcome Preset User!')).toBeInTheDocument();\n    expect(screen.getByText('Theme: light')).toBeInTheDocument();\n  });\n});","testing-user-interactions#Testing User Interactions":"","button-clicks-and-updates#Button Clicks and Updates":"Test components that update state:\nimport { render, screen, fireEvent } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nfunction Counter() {\n  const [count] = useResolves(counterExecutor);\n  const updateCounter = useUpdate(counterExecutor);\n  const increment = () => {\n    updateCounter((current) => ({ count: current.count + 1 }));\n  };\n  return (\n    <div>\n      <p data-testid=\"count\">Count: {count.count}</p>\n      <button onClick={increment}>Increment</button>\n    </div>\n  );\n}\ndescribe('Counter', () => {\n  it('should increment count when button is clicked', async () => {\n    const user = userEvent.setup();\n    const counterExecutor = exec(() => ({ count: 0 }));\n    render(\n      <ScopeProvider>\n        <Counter />\n      </ScopeProvider>\n    );\n    expect(screen.getByTestId('count')).toHaveTextContent('Count: 0');\n    await user.click(screen.getByText('Increment'));\n    expect(screen.getByTestId('count')).toHaveTextContent('Count: 1');\n  });\n});","form-interactions#Form Interactions":"Test form components:\nfunction UserForm() {\n  const [user] = useResolves(userExecutor);\n  const updateUser = useUpdate(userExecutor);\n  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {\n    e.preventDefault();\n    const formData = new FormData(e.currentTarget);\n    const name = formData.get('name') as string;\n    updateUser((current) => ({ ...current, name }));\n  };\n  return (\n    <form onSubmit={handleSubmit}>\n      <input name=\"name\" defaultValue={user.name} />\n      <button type=\"submit\">Update</button>\n      <p data-testid=\"user-name\">{user.name}</p>\n    </form>\n  );\n}\ndescribe('UserForm', () => {\n  it('should update user name when form is submitted', async () => {\n    const user = userEvent.setup();\n    const userExecutor = exec(() => ({ name: 'John' }));\n    render(\n      <ScopeProvider>\n        <UserForm />\n      </ScopeProvider>\n    );\n    const nameInput = screen.getByDisplayValue('John');\n    await user.clear(nameInput);\n    await user.type(nameInput, 'Jane');\n    await user.click(screen.getByText('Update'));\n    expect(screen.getByTestId('user-name')).toHaveTextContent('Jane');\n  });\n});","testing-reactive-components#Testing Reactive Components":"","reactive-updates#Reactive Updates":"Test components that respond to reactive changes:\nfunction ReactiveDisplay() {\n  const [count, doubled] = useResolves(counterExecutor, doubledExecutor);\n  return (\n    <div>\n      <p data-testid=\"count\">Count: {count.count}</p>\n      <p data-testid=\"doubled\">Doubled: {doubled}</p>\n    </div>\n  );\n}\ndescribe('ReactiveDisplay', () => {\n  it('should update doubled value when count changes', () => {\n    const counterExecutor = exec(() => ({ count: 5 }));\n    const doubledExecutor = exec(\n      (state) => state.count * 2,\n      counterExecutor.reactive\n    );\n    const scope = createScope();\n    \n    render(\n      <ScopeProvider scope={scope}>\n        <ReactiveDisplay />\n      </ScopeProvider>\n    );\n    expect(screen.getByTestId('count')).toHaveTextContent('Count: 5');\n    expect(screen.getByTestId('doubled')).toHaveTextContent('Doubled: 10');\n    // Update the counter\n    scope.update(counterExecutor, { count: 7 });\n    expect(screen.getByTestId('count')).toHaveTextContent('Count: 7');\n    expect(screen.getByTestId('doubled')).toHaveTextContent('Doubled: 14');\n  });\n});","multiple-reactive-dependencies#Multiple Reactive Dependencies":"function Calculator() {\n  const [a, b, sum] = useResolves(aExecutor, bExecutor, sumExecutor);\n  return (\n    <div>\n      <p data-testid=\"a\">A: {a}</p>\n      <p data-testid=\"b\">B: {b}</p>\n      <p data-testid=\"sum\">Sum: {sum}</p>\n    </div>\n  );\n}\ndescribe('Calculator', () => {\n  it('should update sum when either input changes', () => {\n    const aExecutor = exec(() => 10);\n    const bExecutor = exec(() => 20);\n    const sumExecutor = exec(\n      (a: number, b: number) => a + b,\n      [aExecutor.reactive, bExecutor.reactive]\n    );\n    const scope = createScope();\n    \n    render(\n      <ScopeProvider scope={scope}>\n        <Calculator />\n      </ScopeProvider>\n    );\n    expect(screen.getByTestId('sum')).toHaveTextContent('Sum: 30');\n    // Update first input\n    scope.update(aExecutor, 15);\n    expect(screen.getByTestId('sum')).toHaveTextContent('Sum: 35');\n    // Update second input\n    scope.update(bExecutor, 25);\n    expect(screen.getByTestId('sum')).toHaveTextContent('Sum: 40');\n  });\n});","testing-async-components#Testing Async Components":"","loading-states#Loading States":"Test components with async data:\nfunction AsyncUserProfile() {\n  const [user] = useResolves(asyncUserExecutor);\n  if (!user) {\n    return <div>Loading...</div>;\n  }\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  );\n}\ndescribe('AsyncUserProfile', () => {\n  it('should show loading state initially', () => {\n    const asyncUserExecutor = exec(async () => {\n      await new Promise(resolve => setTimeout(resolve, 100));\n      return { name: 'John', email: 'john@example.com' };\n    });\n    render(\n      <ScopeProvider>\n        <AsyncUserProfile />\n      </ScopeProvider>\n    );\n    expect(screen.getByText('Loading...')).toBeInTheDocument();\n  });\n  it('should show user data after loading', async () => {\n    const asyncUserExecutor = exec(async () => {\n      return { name: 'John', email: 'john@example.com' };\n    });\n    render(\n      <ScopeProvider>\n        <AsyncUserProfile />\n      </ScopeProvider>\n    );\n    await screen.findByText('John');\n    expect(screen.getByText('john@example.com')).toBeInTheDocument();\n  });\n});","error-boundaries#Error Boundaries":"Test error handling:\nimport { ErrorBoundary } from 'react-error-boundary';\nfunction ErrorFallback({ error }) {\n  return (\n    <div role=\"alert\">\n      <h2>Something went wrong:</h2>\n      <pre>{error.message}</pre>\n    </div>\n  );\n}\nfunction FailingComponent() {\n  const [data] = useResolves(failingExecutor);\n  return <div>{data.value}</div>;\n}\ndescribe('Error Handling', () => {\n  it('should display error when executor fails', () => {\n    const failingExecutor = exec(() => {\n      throw new Error('Network error');\n    });\n    render(\n      <ErrorBoundary FallbackComponent={ErrorFallback}>\n        <ScopeProvider>\n          <FailingComponent />\n        </ScopeProvider>\n      </ErrorBoundary>\n    );\n    expect(screen.getByRole('alert')).toBeInTheDocument();\n    expect(screen.getByText(/Network error/)).toBeInTheDocument();\n  });\n});","testing-with-render-props#Testing with Render Props":"","resolves-component#Resolves Component":"function UserDisplay() {\n  return (\n    <Resolves e={[userExecutor, settingsExecutor]}>\n      {([user, settings]) => (\n        <div>\n          <h1>{user.name}</h1>\n          <p>Theme: {settings.theme}</p>\n        </div>\n      )}\n    </Resolves>\n  );\n}\ndescribe('UserDisplay', () => {\n  it('should render with render props pattern', () => {\n    const userExecutor = exec(() => ({ name: 'John' }));\n    const settingsExecutor = exec(() => ({ theme: 'dark' }));\n    render(\n      <ScopeProvider>\n        <UserDisplay />\n      </ScopeProvider>\n    );\n    expect(screen.getByText('John')).toBeInTheDocument();\n    expect(screen.getByText('Theme: dark')).toBeInTheDocument();\n  });\n});","reselect-component#Reselect Component":"function UserName() {\n  return (\n    <Reselect \n      e={userExecutor}\n      selector={(user) => user.name}\n    >\n      {(name) => <h1>Hello {name}!</h1>}\n    </Reselect>\n  );\n}\ndescribe('UserName', () => {\n  it('should render with selector', () => {\n    const userExecutor = exec(() => ({ \n      name: 'John', \n      email: 'john@example.com' \n    }));\n    render(\n      <ScopeProvider>\n        <UserName />\n      </ScopeProvider>\n    );\n    expect(screen.getByText('Hello John!')).toBeInTheDocument();\n  });\n});","testing-utilities#Testing Utilities":"","custom-render-function#Custom Render Function":"Create a custom render function for convenience:\n// test/utils.tsx\nimport { render } from '@testing-library/react';\nimport { ReactElement } from 'react';\nimport { ScopeProvider } from '@pumped-fn/react';\nimport { createScope } from '@pumped-fn/core-next';\nexport function renderWithScope(\n  ui: ReactElement,\n  { scope = createScope(), ...renderOptions } = {}\n) {\n  function Wrapper({ children }: { children: React.ReactNode }) {\n    return <ScopeProvider scope={scope}>{children}</ScopeProvider>;\n  }\n  return {\n    scope,\n    ...render(ui, { wrapper: Wrapper, ...renderOptions })\n  };\n}\n// Usage\ndescribe('UserProfile', () => {\n  it('should render user information', () => {\n    const { scope } = renderWithScope(<UserProfile />);\n    \n    // Pre-populate scope if needed\n    scope.update(userExecutor, { name: 'Test User' });\n    \n    expect(screen.getByText('Test User')).toBeInTheDocument();\n  });\n});","mock-executors#Mock Executors":"Create mock executors for testing:\n// test/mocks.ts\nimport { vi } from 'vitest';\nimport { exec } from '@pumped-fn/core-next';\nexport function createMockApiExecutor() {\n  return exec(() => ({\n    get: vi.fn(),\n    post: vi.fn(),\n    put: vi.fn(),\n    delete: vi.fn(),\n  }));\n}\nexport function createMockUserExecutor(user = {}) {\n  return exec(() => ({\n    id: '1',\n    name: 'Test User',\n    email: 'test@example.com',\n    ...user,\n  }));\n}\n// Usage\ndescribe('UserService', () => {\n  it('should fetch user data', async () => {\n    const mockApi = createMockApiExecutor();\n    const mockUser = createMockUserExecutor({ name: 'John' });\n    const { scope } = renderWithScope(<UserComponent />);\n    \n    // Setup mock response\n    const api = scope.resolve(mockApi);\n    api.get.mockResolvedValue(scope.resolve(mockUser));\n    // Test implementation\n  });\n});","integration-testing#Integration Testing":"","full-component-trees#Full Component Trees":"Test complete component hierarchies:\nfunction App() {\n  return (\n    <ScopeProvider>\n      <Header />\n      <Dashboard />\n      <Footer />\n    </ScopeProvider>\n  );\n}\ndescribe('App Integration', () => {\n  it('should render complete application', () => {\n    render(<App />);\n    expect(screen.getByRole('banner')).toBeInTheDocument(); // Header\n    expect(screen.getByRole('main')).toBeInTheDocument(); // Dashboard\n    expect(screen.getByRole('contentinfo')).toBeInTheDocument(); // Footer\n  });\n  it('should handle user interactions across components', async () => {\n    const user = userEvent.setup();\n    render(<App />);\n    // Test cross-component interactions\n    await user.click(screen.getByText('Login'));\n    expect(screen.getByText('Welcome!')).toBeInTheDocument();\n  });\n});","performance-testing#Performance Testing":"","render-performance#Render Performance":"Test that components don't re-render unnecessarily:\ndescribe('Performance', () => {\n  it('should not re-render when unrelated data changes', () => {\n    let renderCount = 0;\n    \n    function TestComponent() {\n      renderCount++;\n      const [userName] = useResolves(userNameExecutor);\n      return <div>{userName}</div>;\n    }\n    const userNameExecutor = exec(() => 'John');\n    const unrelatedExecutor = exec(() => 'unrelated');\n    const { scope } = renderWithScope(<TestComponent />);\n    \n    expect(renderCount).toBe(1);\n    \n    // Update unrelated data\n    scope.update(unrelatedExecutor, 'updated');\n    \n    // Component should not re-render\n    expect(renderCount).toBe(1);\n  });\n});","best-practices#Best Practices":"","1-test-behavior-not-implementation#1. Test Behavior, Not Implementation":"// Good - tests behavior\nit('should show user greeting', () => {\n  renderWithScope(<UserGreeting />);\n  expect(screen.getByText(/welcome/i)).toBeInTheDocument();\n});\n// Less good - tests implementation details\nit('should call useResolves with userExecutor', () => {\n  const spy = vi.spyOn(require('@pumped-fn/react'), 'useResolves');\n  renderWithScope(<UserGreeting />);\n  expect(spy).toHaveBeenCalledWith(userExecutor);\n});","2-use-semantic-queries#2. Use Semantic Queries":"// Good - semantic queries\nexpect(screen.getByRole('button', { name: /submit/i })).toBeInTheDocument();\nexpect(screen.getByLabelText(/email/i)).toBeInTheDocument();\n// Less good - implementation details\nexpect(screen.getByClassName('submit-button')).toBeInTheDocument();","3-test-edge-cases#3. Test Edge Cases":"describe('UserList', () => {\n  it('should handle empty user list', () => {\n    const emptyUsersExecutor = exec(() => []);\n    renderWithScope(<UserList />);\n    expect(screen.getByText('No users found')).toBeInTheDocument();\n  });\n  it('should handle loading state', () => {\n    const loadingUsersExecutor = exec(() => null);\n    renderWithScope(<UserList />);\n    expect(screen.getByText('Loading users...')).toBeInTheDocument();\n  });\n});","next-steps#Next Steps":"Testing Utilities - Advanced testing utilities and helpers\nInteractive Testing - Testing complex user interactions\nTesting Executors - Deep dive into executor testing\nTesting React components with Pumped Functions is straightforward and powerful. The separation of concerns makes it easy to test both the logic (executors) and the presentation (components) independently and together."}},"/core-concepts/executors":{"title":"Executors","data":{"":"Executors are the fundamental building blocks of Pumped Functions. They are containers that hold values and define how dependencies are resolved, providing a powerful abstraction for dependency injection and reactive programming.","what-are-executors#What Are Executors?":"An executor is a container that:\nHolds a factory function that creates a value\nDeclares dependencies on other executors\nManages the lifecycle of the value it creates\nProvides different resolution strategies (static, lazy, reactive)\nimport { exec } from '@pumped-fn/core-next';\n// Simple executor with no dependencies\nconst greeting = exec(() => 'Hello, World!');\n// Executor with dependencies\nconst message = exec(\n  (greeting: string, name: string) => `${greeting} ${name}!`,\n  [greeting, nameExecutor]\n);","creating-executors#Creating Executors":"","basic-executor#Basic Executor":"The simplest executor takes a factory function:\nimport { exec } from '@pumped-fn/core-next';\nconst config = exec(() => ({\n  apiUrl: 'https://api.example.com',\n  timeout: 5000,\n}));","executor-with-dependencies#Executor with Dependencies":"Pass dependencies as the second parameter:\nconst apiClient = exec(\n  (config: Config) => new ApiClient(config),\n  config // Single dependency\n);\nconst userService = exec(\n  (client: ApiClient, logger: Logger) => new UserService(client, logger),\n  [apiClient, logger] // Multiple dependencies as array\n);","object-dependencies#Object Dependencies":"Use objects to name your dependencies:\nconst combinedService = exec(\n  ({ api, cache, logger }) => new CombinedService(api, cache, logger),\n  {\n    api: apiClient,\n    cache: cacheService,\n    logger: loggerService,\n  }\n);","resolution-strategies#Resolution Strategies":"Executors support different resolution strategies that control when and how values are created:","static-resolution-default#Static Resolution (Default)":"Static executors resolve once and cache the result:\nconst database = exec(() => new Database());\n// Or explicitly: database.static","lazy-resolution#Lazy Resolution":"Lazy executors only resolve when their value is actually needed:\nconst expensiveService = exec(() => {\n  console.log('Creating expensive service...');\n  return new ExpensiveService();\n});\n// Use lazy resolution\nconst maybeUseService = exec(\n  (service: ExpensiveService) => Math.random() > 0.5 ? service : null,\n  expensiveService.lazy // Only creates service if needed\n);","reactive-resolution#Reactive Resolution":"Reactive executors automatically re-resolve when their dependencies change:\nconst counter = exec(() => ({ count: 0 }));\nconst doubled = exec(\n  (state) => state.count * 2,\n  counter.reactive // Re-resolves when counter changes\n);","dependency-patterns#Dependency Patterns":"","array-dependencies#Array Dependencies":"When you need multiple dependencies in order:\nconst fullName = exec(\n  (firstName: string, lastName: string) => `${firstName} ${lastName}`,\n  [firstNameExecutor, lastNameExecutor]\n);","object-dependencies-1#Object Dependencies":"When you want to name your dependencies:\nconst userProfile = exec(\n  ({ name, email, preferences }) => ({\n    displayName: name,\n    contactEmail: email,\n    theme: preferences.theme,\n  }),\n  {\n    name: userName,\n    email: userEmail,\n    preferences: userPreferences,\n  }\n);","mixed-dependencies#Mixed Dependencies":"You can mix static and reactive dependencies:\nconst dynamicComponent = exec(\n  (staticConfig: Config, liveData: LiveData) => \n    new Component(staticConfig, liveData),\n  {\n    staticConfig: configExecutor,         // Static\n    liveData: dataExecutor.reactive,      // Reactive\n  }\n);","scopes-and-resolution#Scopes and Resolution":"Executors don't resolve themselves - they need a scope to manage their lifecycle:\nimport { createScope } from '@pumped-fn/core-next';\nconst scope = createScope();\nconst result = scope.resolve(myExecutor);","scope-management#Scope Management":"Scopes provide several methods for managing executors:\nconst scope = createScope();\n// Resolve an executor\nconst value = scope.resolve(myExecutor);\n// Update an executor's value\nscope.update(myExecutor, newValue);\nscope.update(myExecutor, (current) => ({ ...current, updated: true }));\n// Release an executor (cleanup)\nscope.release(myExecutor);\n// Check if an executor is resolved\nconst isResolved = scope.has(myExecutor);","async-executors#Async Executors":"Executors can handle asynchronous operations:\nconst userData = exec(async () => {\n  const response = await fetch('/api/user');\n  return response.json();\n});\nconst userProfile = exec(\n  async (userData: UserData, preferences: Preferences) => {\n    return {\n      ...userData,\n      theme: preferences.theme,\n    };\n  },\n  [userData, userPreferences]\n);\n// Resolving async executors\nconst scope = createScope();\nconst profile = await scope.resolve(userProfile);","error-handling#Error Handling":"Executors can throw errors, which are propagated through the dependency chain:\nconst riskyService = exec(() => {\n  if (Math.random() > 0.5) {\n    throw new Error('Service unavailable');\n  }\n  return new Service();\n});\nconst safeService = exec(\n  (service: Service) => service,\n  riskyService\n);\n// Handle errors during resolution\nconst scope = createScope();\ntry {\n  const service = scope.resolve(safeService);\n} catch (error) {\n  console.error('Service failed to initialize:', error);\n}","advanced-patterns#Advanced Patterns":"","conditional-dependencies#Conditional Dependencies":"Use lazy resolution for conditional dependencies:\nconst isDevelopment = exec(() => process.env.NODE_ENV === 'development');\nconst logger = exec(\n  (isDev: boolean) => isDev ? new ConsoleLogger() : new NoOpLogger(),\n  isDevelopment\n);\nconst debugService = exec(\n  (logger: Logger) => new DebugService(logger),\n  logger.lazy // Only creates if logger is actually used\n);","factory-pattern#Factory Pattern":"Create executors that return factory functions:\nconst apiClientFactory = exec(\n  (config: Config) => (baseUrl: string) => new ApiClient(config, baseUrl),\n  config\n);\nconst userApiClient = exec(\n  (factory: ApiClientFactory) => factory('/api/users'),\n  apiClientFactory\n);","parameterized-executors#Parameterized Executors":"Create executors that accept parameters:\nconst createUserService = (userId: string) => exec(\n  (api: ApiClient) => new UserService(api, userId),\n  apiClient\n);\nconst currentUserService = exec(\n  (currentUserId: string) => createUserService(currentUserId),\n  currentUserIdExecutor\n);","testing-executors#Testing Executors":"Executors are easy to test in isolation:\nimport { describe, it, expect } from 'vitest';\nimport { createScope } from '@pumped-fn/core-next';\ndescribe('Calculator', () => {\n  it('should add two numbers', () => {\n    const a = exec(() => 5);\n    const b = exec(() => 3);\n    const sum = exec((a: number, b: number) => a + b, [a, b]);\n    const scope = createScope();\n    const result = scope.resolve(sum);\n    expect(result).toBe(8);\n  });\n  it('should handle async operations', async () => {\n    const asyncValue = exec(async () => {\n      await new Promise(resolve => setTimeout(resolve, 10));\n      return 'async result';\n    });\n    const scope = createScope();\n    const result = await scope.resolve(asyncValue);\n    expect(result).toBe('async result');\n  });\n});","best-practices#Best Practices":"","1-keep-executors-pure#1. Keep Executors Pure":"Executors should be pure functions when possible:\n// Good - pure function\nconst calculateTotal = exec(\n  (items: Item[]) => items.reduce((sum, item) => sum + item.price, 0),\n  itemsExecutor\n);\n// Avoid - side effects in executor\nconst updateDatabase = exec(\n  (data: Data) => {\n    database.save(data); // Side effect\n    return data;\n  },\n  dataExecutor\n);","2-use-descriptive-names#2. Use Descriptive Names":"Make your executors self-documenting:\n// Good\nconst currentUserProfile = exec(/* ... */);\nconst authenticatedApiClient = exec(/* ... */);\n// Less clear\nconst user = exec(/* ... */);\nconst client = exec(/* ... */);","3-organize-dependencies#3. Organize Dependencies":"Group related executors together:\n// auth.ts\nexport const authToken = exec(/* ... */);\nexport const currentUser = exec(/* ... */);\n// api.ts\nexport const apiClient = exec(/* ... */, [authToken]);\nexport const userService = exec(/* ... */, [apiClient]);","4-use-type-annotations#4. Use Type Annotations":"Help TypeScript infer types correctly:\ninterface Config {\n  apiUrl: string;\n  timeout: number;\n}\nconst config = exec((): Config => ({\n  apiUrl: process.env.API_URL || 'http://localhost:3000',\n  timeout: 5000,\n}));","performance-considerations#Performance Considerations":"","lazy-loading#Lazy Loading":"Use lazy resolution for expensive operations:\nconst expensiveComputation = exec(() => {\n  // Expensive operation\n  return computeComplexValue();\n});\nconst conditionalResult = exec(\n  (condition: boolean, value: ComplexValue) => \n    condition ? value : null,\n  [conditionExecutor, expensiveComputation.lazy]\n);","reactive-optimization#Reactive Optimization":"Be mindful of reactive dependencies to avoid unnecessary re-computations:\n// Good - specific reactive dependency\nconst userDisplayName = exec(\n  (user) => user.name,\n  userExecutor.reactive\n);\n// Less efficient - entire state is reactive\nconst userDisplayName = exec(\n  (appState) => appState.user.name,\n  appStateExecutor.reactive\n);","common-pitfalls#Common Pitfalls":"","1-circular-dependencies#1. Circular Dependencies":"Avoid circular dependencies between executors:\n// Don't do this\nconst a = exec((b: any) => b + 1, b);\nconst b = exec((a: any) => a + 1, a); // Circular!","2-mutating-dependencies#2. Mutating Dependencies":"Don't mutate values from dependencies:\n// Don't do this\nconst mutateConfig = exec(\n  (config: Config) => {\n    config.apiUrl = 'modified'; // Don't mutate!\n    return config;\n  },\n  configExecutor\n);\n// Do this instead\nconst modifiedConfig = exec(\n  (config: Config) => ({\n    ...config,\n    apiUrl: 'modified',\n  }),\n  configExecutor\n);","3-side-effects-in-executors#3. Side Effects in Executors":"Avoid side effects in executor factories:\n// Don't do this\nconst sideEffectExecutor = exec(() => {\n  console.log('Creating value'); // Side effect\n  localStorage.setItem('key', 'value'); // Side effect\n  return 'value';\n});\n// Do this instead - separate concerns\nconst value = exec(() => 'value');\nconst logValue = exec((val: string) => {\n  console.log('Value created:', val);\n  return val;\n}, value);","next-steps#Next Steps":"Now that you understand executors, explore:\nReact Integration - Using executors with React\nTesting - Testing strategies for executors\nExamples - Real-world examples\nExecutors are the foundation of Pumped Functions. Master them, and you'll be able to build maintainable, testable, and reactive applications with ease."}},"/examples/counter":{"title":"Counter App Example","data":{"":"A comprehensive counter application demonstrating core Pumped Functions concepts including state management, reactive programming, and React integration.","overview#Overview":"This example showcases:\nBasic state management with executors\nReactive derived state\nReact hooks integration\nMultiple counter instances\nPersistence with localStorage\nTesting strategies","basic-counter#Basic Counter":"Let's start with a simple counter:\n// src/executors/counter.ts\nimport { exec } from '@pumped-fn/core-next';\nexport interface CounterState {\n  count: number;\n  step: number;\n}\n// Core counter state\nexport const counterState = exec((): CounterState => ({\n  count: 0,\n  step: 1,\n}));\n// Derived state - counter display text\nexport const counterDisplay = exec(\n  (state: CounterState) => `Count: ${state.count}`,\n  counterState.reactive\n);\n// Derived state - is even/odd\nexport const isEven = exec(\n  (state: CounterState) => state.count % 2 === 0,\n  counterState.reactive\n);","action-creators#Action Creators":"Create actions to modify the counter state:\n// src/executors/actions.ts\nimport { exec } from '@pumped-fn/core-next';\nimport { CounterState } from './counter';\n// Action: Increment counter\nexport const increment = exec(\n  () => (state: CounterState): CounterState => ({\n    ...state,\n    count: state.count + state.step,\n  })\n);\n// Action: Decrement counter\nexport const decrement = exec(\n  () => (state: CounterState): CounterState => ({\n    ...state,\n    count: state.count - state.step,\n  })\n);\n// Action: Reset counter\nexport const reset = exec(\n  () => (state: CounterState): CounterState => ({\n    ...state,\n    count: 0,\n  })\n);\n// Action: Set step size\nexport const setStep = exec(\n  (step: number) => (state: CounterState): CounterState => ({\n    ...state,\n    step,\n  })\n);\n// Action: Set count directly\nexport const setCount = exec(\n  (count: number) => (state: CounterState): CounterState => ({\n    ...state,\n    count,\n  })\n);","react-components#React Components":"","basic-counter-component#Basic Counter Component":"// src/components/Counter.tsx\nimport React from 'react';\nimport { useResolves, useUpdate } from '@pumped-fn/react';\nimport { counterState, counterDisplay, isEven } from '../executors/counter';\nimport { increment, decrement, reset } from '../executors/actions';\nexport function Counter() {\n  const [state, display, even] = useResolves(counterState, counterDisplay, isEven);\n  const updateCounter = useUpdate(counterState);\n  const handleIncrement = () => {\n    updateCounter(increment());\n  };\n  const handleDecrement = () => {\n    updateCounter(decrement());\n  };\n  const handleReset = () => {\n    updateCounter(reset());\n  };\n  return (\n    <div className=\"counter\">\n      <h2>{display}</h2>\n      <p className={even ? 'even' : 'odd'}>\n        {even ? 'Even' : 'Odd'}\n      </p>\n      \n      <div className=\"controls\">\n        <button onClick={handleDecrement}>-</button>\n        <button onClick={handleReset}>Reset</button>\n        <button onClick={handleIncrement}>+</button>\n      </div>\n      \n      <div className=\"step-control\">\n        <label>\n          Step size: \n          <input\n            type=\"number\"\n            value={state.step}\n            onChange={(e) => updateCounter(setStep(parseInt(e.target.value) || 1))}\n            min=\"1\"\n          />\n        </label>\n      </div>\n    </div>\n  );\n}","advanced-counter-with-statistics#Advanced Counter with Statistics":"// src/executors/stats.ts\nimport { exec } from '@pumped-fn/core-next';\nimport { counterState } from './counter';\nexport interface CounterStats {\n  totalIncrements: number;\n  totalDecrements: number;\n  maxValue: number;\n  minValue: number;\n  operations: string[];\n}\nexport const counterStats = exec((): CounterStats => ({\n  totalIncrements: 0,\n  totalDecrements: 0,\n  maxValue: 0,\n  minValue: 0,\n  operations: [],\n}));\n// Track statistics when counter changes\nexport const statsUpdater = exec(\n  (state: CounterState, stats: CounterStats) => {\n    // This would be called by actions to update stats\n    return stats;\n  },\n  [counterState.reactive, counterStats.reactive]\n);\n// src/components/CounterWithStats.tsx\nimport React from 'react';\nimport { useResolves, useUpdate } from '@pumped-fn/react';\nimport { counterState } from '../executors/counter';\nimport { counterStats } from '../executors/stats';\nexport function CounterWithStats() {\n  const [state, stats] = useResolves(counterState, counterStats);\n  const updateCounter = useUpdate(counterState);\n  const updateStats = useUpdate(counterStats);\n  const incrementWithStats = () => {\n    const newCount = state.count + state.step;\n    updateCounter(current => ({ ...current, count: newCount }));\n    updateStats(current => ({\n      ...current,\n      totalIncrements: current.totalIncrements + 1,\n      maxValue: Math.max(current.maxValue, newCount),\n      operations: [...current.operations, `+${state.step} â†’ ${newCount}`],\n    }));\n  };\n  const decrementWithStats = () => {\n    const newCount = state.count - state.step;\n    updateCounter(current => ({ ...current, count: newCount }));\n    updateStats(current => ({\n      ...current,\n      totalDecrements: current.totalDecrements + 1,\n      minValue: Math.min(current.minValue, newCount),\n      operations: [...current.operations, `-${state.step} â†’ ${newCount}`],\n    }));\n  };\n  return (\n    <div className=\"counter-with-stats\">\n      <div className=\"counter-display\">\n        <h2>Count: {state.count}</h2>\n        <div className=\"controls\">\n          <button onClick={decrementWithStats}>-{state.step}</button>\n          <button onClick={incrementWithStats}>+{state.step}</button>\n        </div>\n      </div>\n      \n      <div className=\"stats\">\n        <h3>Statistics</h3>\n        <ul>\n          <li>Increments: {stats.totalIncrements}</li>\n          <li>Decrements: {stats.totalDecrements}</li>\n          <li>Max Value: {stats.maxValue}</li>\n          <li>Min Value: {stats.minValue}</li>\n        </ul>\n        \n        <div className=\"operations\">\n          <h4>Recent Operations</h4>\n          <ul>\n            {stats.operations.slice(-5).map((op, index) => (\n              <li key={index}>{op}</li>\n            ))}\n          </ul>\n        </div>\n      </div>\n    </div>\n  );\n}","multiple-counter-instances#Multiple Counter Instances":"Create a system for managing multiple counters:\n// src/executors/multiCounter.ts\nimport { exec } from '@pumped-fn/core-next';\nexport interface Counter {\n  id: string;\n  name: string;\n  count: number;\n  step: number;\n}\nexport interface MultiCounterState {\n  counters: Counter[];\n  activeCounterId: string | null;\n}\nexport const multiCounterState = exec((): MultiCounterState => ({\n  counters: [],\n  activeCounterId: null,\n}));\n// Derived state - active counter\nexport const activeCounter = exec(\n  (state: MultiCounterState): Counter | null => {\n    return state.counters.find(c => c.id === state.activeCounterId) || null;\n  },\n  multiCounterState.reactive\n);\n// Derived state - counter totals\nexport const counterTotals = exec(\n  (state: MultiCounterState) => ({\n    totalCount: state.counters.reduce((sum, c) => sum + c.count, 0),\n    averageCount: state.counters.length > 0 \n      ? state.counters.reduce((sum, c) => sum + c.count, 0) / state.counters.length \n      : 0,\n    maxCount: Math.max(...state.counters.map(c => c.count), 0),\n    minCount: Math.min(...state.counters.map(c => c.count), 0),\n  }),\n  multiCounterState.reactive\n);\n// src/components/MultiCounterManager.tsx\nimport React, { useState } from 'react';\nimport { useResolves, useUpdate } from '@pumped-fn/react';\nimport { multiCounterState, activeCounter, counterTotals } from '../executors/multiCounter';\nexport function MultiCounterManager() {\n  const [state, active, totals] = useResolves(multiCounterState, activeCounter, counterTotals);\n  const updateState = useUpdate(multiCounterState);\n  const [newCounterName, setNewCounterName] = useState('');\n  const addCounter = () => {\n    if (!newCounterName.trim()) return;\n    \n    const newCounter = {\n      id: crypto.randomUUID(),\n      name: newCounterName.trim(),\n      count: 0,\n      step: 1,\n    };\n    updateState(current => ({\n      ...current,\n      counters: [...current.counters, newCounter],\n      activeCounterId: newCounter.id,\n    }));\n    setNewCounterName('');\n  };\n  const removeCounter = (id: string) => {\n    updateState(current => ({\n      counters: current.counters.filter(c => c.id !== id),\n      activeCounterId: current.activeCounterId === id ? null : current.activeCounterId,\n    }));\n  };\n  const updateCounter = (id: string, updates: Partial<Counter>) => {\n    updateState(current => ({\n      ...current,\n      counters: current.counters.map(c =>\n        c.id === id ? { ...c, ...updates } : c\n      ),\n    }));\n  };\n  const setActiveCounter = (id: string) => {\n    updateState(current => ({\n      ...current,\n      activeCounterId: id,\n    }));\n  };\n  return (\n    <div className=\"multi-counter-manager\">\n      <div className=\"header\">\n        <h2>Multi-Counter Manager</h2>\n        \n        <div className=\"add-counter\">\n          <input\n            type=\"text\"\n            value={newCounterName}\n            onChange={(e) => setNewCounterName(e.target.value)}\n            placeholder=\"Counter name\"\n            onKeyPress={(e) => e.key === 'Enter' && addCounter()}\n          />\n          <button onClick={addCounter}>Add Counter</button>\n        </div>\n      </div>\n      <div className=\"totals\">\n        <h3>Totals</h3>\n        <div className=\"totals-grid\">\n          <div>Total: {totals.totalCount}</div>\n          <div>Average: {totals.averageCount.toFixed(1)}</div>\n          <div>Max: {totals.maxCount}</div>\n          <div>Min: {totals.minCount}</div>\n        </div>\n      </div>\n      <div className=\"counters-grid\">\n        <div className=\"counter-list\">\n          <h3>Counters</h3>\n          {state.counters.map(counter => (\n            <div\n              key={counter.id}\n              className={`counter-item ${counter.id === state.activeCounterId ? 'active' : ''}`}\n              onClick={() => setActiveCounter(counter.id)}\n            >\n              <div className=\"counter-info\">\n                <strong>{counter.name}</strong>\n                <span>Count: {counter.count}</span>\n              </div>\n              <div className=\"counter-controls\">\n                <button onClick={(e) => {\n                  e.stopPropagation();\n                  updateCounter(counter.id, { count: counter.count - counter.step });\n                }}>\n                  -\n                </button>\n                <button onClick={(e) => {\n                  e.stopPropagation();\n                  updateCounter(counter.id, { count: counter.count + counter.step });\n                }}>\n                  +\n                </button>\n                <button onClick={(e) => {\n                  e.stopPropagation();\n                  removeCounter(counter.id);\n                }}>\n                  Ã—\n                </button>\n              </div>\n            </div>\n          ))}\n        </div>\n        <div className=\"active-counter\">\n          {active ? (\n            <div>\n              <h3>Active Counter: {active.name}</h3>\n              <div className=\"counter-detail\">\n                <div className=\"count-display\">\n                  <h1>{active.count}</h1>\n                </div>\n                <div className=\"controls\">\n                  <button onClick={() => updateCounter(active.id, { count: active.count - active.step })}>\n                    -{active.step}\n                  </button>\n                  <button onClick={() => updateCounter(active.id, { count: 0 })}>\n                    Reset\n                  </button>\n                  <button onClick={() => updateCounter(active.id, { count: active.count + active.step })}>\n                    +{active.step}\n                  </button>\n                </div>\n                <div className=\"step-control\">\n                  <label>\n                    Step: \n                    <input\n                      type=\"number\"\n                      value={active.step}\n                      onChange={(e) => updateCounter(active.id, { step: parseInt(e.target.value) || 1 })}\n                      min=\"1\"\n                    />\n                  </label>\n                </div>\n              </div>\n            </div>\n          ) : (\n            <div className=\"no-active\">\n              <p>Select a counter to edit</p>\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n}","persistence#Persistence":"Add localStorage persistence:\n// src/executors/persistence.ts\nimport { exec } from '@pumped-fn/core-next';\nimport { CounterState } from './counter';\nimport { MultiCounterState } from './multiCounter';\nconst STORAGE_KEYS = {\n  counter: 'pumped-counter',\n  multiCounter: 'pumped-multi-counter',\n};\n// Load counter state from localStorage\nexport const loadCounterState = exec((): CounterState => {\n  try {\n    const saved = localStorage.getItem(STORAGE_KEYS.counter);\n    if (saved) {\n      return JSON.parse(saved);\n    }\n  } catch (error) {\n    console.warn('Failed to load counter state:', error);\n  }\n  return { count: 0, step: 1 };\n});\n// Save counter state to localStorage\nexport const saveCounterState = exec(\n  (state: CounterState) => {\n    try {\n      localStorage.setItem(STORAGE_KEYS.counter, JSON.stringify(state));\n    } catch (error) {\n      console.warn('Failed to save counter state:', error);\n    }\n  }\n);\n// Load multi-counter state\nexport const loadMultiCounterState = exec((): MultiCounterState => {\n  try {\n    const saved = localStorage.getItem(STORAGE_KEYS.multiCounter);\n    if (saved) {\n      return JSON.parse(saved);\n    }\n  } catch (error) {\n    console.warn('Failed to load multi-counter state:', error);\n  }\n  return { counters: [], activeCounterId: null };\n});\n// Save multi-counter state\nexport const saveMultiCounterState = exec(\n  (state: MultiCounterState) => {\n    try {\n      localStorage.setItem(STORAGE_KEYS.multiCounter, JSON.stringify(state));\n    } catch (error) {\n      console.warn('Failed to save multi-counter state:', error);\n    }\n  }\n);\nUpdate the counter executors to use persistence:\n// src/executors/counter.ts (updated)\nimport { exec } from '@pumped-fn/core-next';\nimport { loadCounterState, saveCounterState } from './persistence';\nexport interface CounterState {\n  count: number;\n  step: number;\n}\n// Core counter state with persistence\nexport const counterState = exec(\n  (initialState: CounterState): CounterState => initialState,\n  loadCounterState\n);\n// Auto-save when state changes\nexport const counterPersistence = exec(\n  (state: CounterState) => {\n    saveCounterState(state);\n    return state;\n  },\n  counterState.reactive\n);\n// Rest of the executors remain the same...","main-application#Main Application":"Put it all together:\n// src/App.tsx\nimport React from 'react';\nimport { ScopeProvider, Effect } from '@pumped-fn/react';\nimport { Counter } from './components/Counter';\nimport { CounterWithStats } from './components/CounterWithStats';\nimport { MultiCounterManager } from './components/MultiCounterManager';\nimport { counterPersistence } from './executors/counter';\nimport './App.css';\nfunction App() {\n  return (\n    <ScopeProvider>\n      <Effect e={[counterPersistence]} />\n      <div className=\"app\">\n        <header>\n          <h1>Counter Examples</h1>\n        </header>\n        \n        <main>\n          <section>\n            <h2>Basic Counter</h2>\n            <Counter />\n          </section>\n          \n          <section>\n            <h2>Counter with Statistics</h2>\n            <CounterWithStats />\n          </section>\n          \n          <section>\n            <h2>Multi-Counter Manager</h2>\n            <MultiCounterManager />\n          </section>\n        </main>\n      </div>\n    </ScopeProvider>\n  );\n}\nexport default App;","styling#Styling":"Add some CSS to make it look good:\n/* src/App.css */\n.app {\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 20px;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;\n}\n.app header {\n  text-align: center;\n  margin-bottom: 40px;\n}\n.app section {\n  margin-bottom: 40px;\n  padding: 20px;\n  border: 1px solid #ddd;\n  border-radius: 8px;\n}\n.counter {\n  text-align: center;\n  max-width: 400px;\n  margin: 0 auto;\n}\n.counter h2 {\n  font-size: 2em;\n  margin-bottom: 10px;\n}\n.counter .even {\n  color: #007bff;\n}\n.counter .odd {\n  color: #dc3545;\n}\n.controls {\n  display: flex;\n  gap: 10px;\n  justify-content: center;\n  margin: 20px 0;\n}\n.controls button {\n  padding: 10px 20px;\n  font-size: 16px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  background: white;\n  cursor: pointer;\n}\n.controls button:hover {\n  background: #f8f9fa;\n}\n.step-control {\n  margin-top: 20px;\n}\n.step-control input {\n  margin-left: 10px;\n  padding: 5px;\n  width: 60px;\n}\n.counter-with-stats {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  gap: 20px;\n}\n.stats ul {\n  list-style: none;\n  padding: 0;\n}\n.stats li {\n  padding: 5px 0;\n  border-bottom: 1px solid #eee;\n}\n.multi-counter-manager {\n  max-width: 800px;\n  margin: 0 auto;\n}\n.add-counter {\n  display: flex;\n  gap: 10px;\n  margin-bottom: 20px;\n}\n.add-counter input {\n  flex: 1;\n  padding: 8px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n}\n.totals-grid {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  gap: 10px;\n  padding: 10px;\n  background: #f8f9fa;\n  border-radius: 4px;\n}\n.counters-grid {\n  display: grid;\n  grid-template-columns: 1fr 1fr;\n  gap: 20px;\n}\n.counter-item {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 10px;\n  border: 1px solid #ddd;\n  border-radius: 4px;\n  cursor: pointer;\n  margin-bottom: 5px;\n}\n.counter-item:hover {\n  background: #f8f9fa;\n}\n.counter-item.active {\n  border-color: #007bff;\n  background: #e3f2fd;\n}\n.counter-controls {\n  display: flex;\n  gap: 5px;\n}\n.counter-controls button {\n  padding: 5px 10px;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  background: white;\n  cursor: pointer;\n}\n.count-display h1 {\n  font-size: 3em;\n  margin: 20px 0;\n  text-align: center;\n}\n.no-active {\n  text-align: center;\n  padding: 40px;\n  color: #666;\n}","testing#Testing":"Comprehensive tests for the counter application:\n// src/__tests__/counter.test.ts\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { createScope } from '@pumped-fn/core-next';\nimport { counterState, counterDisplay, isEven } from '../executors/counter';\nimport { increment, decrement, reset, setStep } from '../executors/actions';\ndescribe('Counter', () => {\n  let scope: Scope;\n  beforeEach(() => {\n    scope = createScope();\n  });\n  it('should have initial state', () => {\n    const state = scope.resolve(counterState);\n    expect(state).toEqual({ count: 0, step: 1 });\n  });\n  it('should increment count', () => {\n    scope.update(counterState, increment());\n    const state = scope.resolve(counterState);\n    expect(state.count).toBe(1);\n  });\n  it('should decrement count', () => {\n    scope.update(counterState, decrement());\n    const state = scope.resolve(counterState);\n    expect(state.count).toBe(-1);\n  });\n  it('should reset count', () => {\n    scope.update(counterState, increment());\n    scope.update(counterState, increment());\n    scope.update(counterState, reset());\n    \n    const state = scope.resolve(counterState);\n    expect(state.count).toBe(0);\n  });\n  it('should update step size', () => {\n    scope.update(counterState, setStep(5));\n    scope.update(counterState, increment());\n    \n    const state = scope.resolve(counterState);\n    expect(state.count).toBe(5);\n  });\n  it('should update display text reactively', () => {\n    const initialDisplay = scope.resolve(counterDisplay);\n    expect(initialDisplay).toBe('Count: 0');\n    scope.update(counterState, increment());\n    const updatedDisplay = scope.resolve(counterDisplay);\n    expect(updatedDisplay).toBe('Count: 1');\n  });\n  it('should determine even/odd correctly', () => {\n    expect(scope.resolve(isEven)).toBe(true); // 0 is even\n    scope.update(counterState, increment());\n    expect(scope.resolve(isEven)).toBe(false); // 1 is odd\n    scope.update(counterState, increment());\n    expect(scope.resolve(isEven)).toBe(true); // 2 is even\n  });\n});\n// src/__tests__/multiCounter.test.ts\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { createScope } from '@pumped-fn/core-next';\nimport { multiCounterState, activeCounter, counterTotals } from '../executors/multiCounter';\ndescribe('MultiCounter', () => {\n  let scope: Scope;\n  beforeEach(() => {\n    scope = createScope();\n  });\n  it('should start with empty state', () => {\n    const state = scope.resolve(multiCounterState);\n    expect(state).toEqual({\n      counters: [],\n      activeCounterId: null,\n    });\n  });\n  it('should add counters', () => {\n    const newCounter = {\n      id: '1',\n      name: 'Counter 1',\n      count: 0,\n      step: 1,\n    };\n    scope.update(multiCounterState, current => ({\n      ...current,\n      counters: [...current.counters, newCounter],\n    }));\n    const state = scope.resolve(multiCounterState);\n    expect(state.counters).toHaveLength(1);\n    expect(state.counters[0]).toEqual(newCounter);\n  });\n  it('should calculate totals correctly', () => {\n    const counters = [\n      { id: '1', name: 'Counter 1', count: 5, step: 1 },\n      { id: '2', name: 'Counter 2', count: 10, step: 1 },\n      { id: '3', name: 'Counter 3', count: 15, step: 1 },\n    ];\n    scope.update(multiCounterState, current => ({\n      ...current,\n      counters,\n    }));\n    const totals = scope.resolve(counterTotals);\n    expect(totals.totalCount).toBe(30);\n    expect(totals.averageCount).toBe(10);\n    expect(totals.maxCount).toBe(15);\n    expect(totals.minCount).toBe(5);\n  });\n  it('should track active counter', () => {\n    const counters = [\n      { id: '1', name: 'Counter 1', count: 5, step: 1 },\n      { id: '2', name: 'Counter 2', count: 10, step: 1 },\n    ];\n    scope.update(multiCounterState, current => ({\n      counters,\n      activeCounterId: '2',\n    }));\n    const active = scope.resolve(activeCounter);\n    expect(active).toEqual(counters[1]);\n  });\n});","react-component-tests#React Component Tests":"// src/__tests__/Counter.test.tsx\nimport { render, screen } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { ScopeProvider } from '@pumped-fn/react';\nimport { Counter } from '../components/Counter';\ndescribe('Counter Component', () => {\n  it('should render initial state', () => {\n    render(\n      <ScopeProvider>\n        <Counter />\n      </ScopeProvider>\n    );\n    expect(screen.getByText('Count: 0')).toBeInTheDocument();\n    expect(screen.getByText('Even')).toBeInTheDocument();\n  });\n  it('should increment when + button is clicked', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <ScopeProvider>\n        <Counter />\n      </ScopeProvider>\n    );\n    await user.click(screen.getByText('+'));\n    expect(screen.getByText('Count: 1')).toBeInTheDocument();\n    expect(screen.getByText('Odd')).toBeInTheDocument();\n  });\n  it('should update step size', async () => {\n    const user = userEvent.setup();\n    \n    render(\n      <ScopeProvider>\n        <Counter />\n      </ScopeProvider>\n    );\n    const stepInput = screen.getByDisplayValue('1');\n    await user.clear(stepInput);\n    await user.type(stepInput, '5');\n    await user.click(screen.getByText('+'));\n    expect(screen.getByText('Count: 5')).toBeInTheDocument();\n  });\n});","key-patterns-demonstrated#Key Patterns Demonstrated":"This counter example showcases several important patterns:","1-state-management#1. State Management":"Single source of truth with executors\nImmutable state updates\nClear action creators","2-reactive-programming#2. Reactive Programming":"Derived state that updates automatically\nReactive chains for complex calculations\nEfficient re-rendering in React","3-modular-architecture#3. Modular Architecture":"Separate concerns (state, actions, components)\nReusable executors\nClean component interfaces","4-persistence#4. Persistence":"localStorage integration\nAutomatic state saving\nError handling for storage operations","5-testing#5. Testing":"Unit tests for executors\nIntegration tests for components\nComprehensive test coverage","running-the-example#Running the Example":"To run this example:\nCreate a new React project\nInstall dependencies: pnpm add @pumped-fn/core-next @pumped-fn/react\nCopy the code from this example\nRun pnpm start","next-steps#Next Steps":"This counter example provides a solid foundation. You can extend it with:\nReal-time synchronization across tabs\nUndo/redo functionality\nCounter themes and customization\nExport/import counter configurations\nAdvanced animations and transitions\nThe patterns shown here scale to much larger applications while maintaining simplicity and testability."}},"/getting-started/first-app":{"title":"Your First App","data":{"":"Build a complete todo application with Pumped Functions and React. This tutorial will teach you real-world patterns and best practices.","what-well-build#What We'll Build":"A todo application with:\nAdd, complete, and remove todos\nFilter by completion status\nReal-time updates across components\nPersistent state\nType-safe implementation","project-setup#Project Setup":"First, create a new React project and install dependencies:\nnpx create-react-app my-todo-app --template typescript\ncd my-todo-app\npnpm add @pumped-fn/core-next @pumped-fn/react","define-the-data-model#Define the Data Model":"Start by defining the types and core data structures:\n// src/types.ts\nexport interface Todo {\n  id: string;\n  text: string;\n  completed: boolean;\n  createdAt: Date;\n}\nexport type FilterType = 'all' | 'active' | 'completed';\nexport interface TodoState {\n  todos: Todo[];\n  filter: FilterType;\n}","create-the-core-executors#Create the Core Executors":"Create executors to manage the application state:\n// src/executors/todos.ts\nimport { exec } from '@pumped-fn/core-next';\nimport { Todo, TodoState, FilterType } from '../types';\n// Core state executor\nexport const todoState = exec((): TodoState => ({\n  todos: [],\n  filter: 'all',\n}));\n// Derived state - filtered todos\nexport const filteredTodos = exec(\n  (state: TodoState): Todo[] => {\n    switch (state.filter) {\n      case 'active':\n        return state.todos.filter(todo => !todo.completed);\n      case 'completed':\n        return state.todos.filter(todo => todo.completed);\n      default:\n        return state.todos;\n    }\n  },\n  todoState.reactive\n);\n// Derived state - todo counts\nexport const todoStats = exec(\n  (state: TodoState) => {\n    const total = state.todos.length;\n    const completed = state.todos.filter(t => t.completed).length;\n    const active = total - completed;\n    \n    return { total, completed, active };\n  },\n  todoState.reactive\n);","create-action-executors#Create Action Executors":"Create executors for actions that modify the state:\n// src/executors/actions.ts\nimport { exec } from '@pumped-fn/core-next';\nimport { Todo, TodoState, FilterType } from '../types';\nimport { todoState } from './todos';\n// Action: Add a new todo\nexport const addTodo = exec(\n  (text: string) => (state: TodoState): TodoState => ({\n    ...state,\n    todos: [\n      ...state.todos,\n      {\n        id: crypto.randomUUID(),\n        text,\n        completed: false,\n        createdAt: new Date(),\n      },\n    ],\n  }),\n  [/* no dependencies - pure action */]\n);\n// Action: Toggle todo completion\nexport const toggleTodo = exec(\n  (id: string) => (state: TodoState): TodoState => ({\n    ...state,\n    todos: state.todos.map(todo =>\n      todo.id === id ? { ...todo, completed: !todo.completed } : todo\n    ),\n  }),\n  [/* no dependencies - pure action */]\n);\n// Action: Remove todo\nexport const removeTodo = exec(\n  (id: string) => (state: TodoState): TodoState => ({\n    ...state,\n    todos: state.todos.filter(todo => todo.id !== id),\n  }),\n  [/* no dependencies - pure action */]\n);\n// Action: Set filter\nexport const setFilter = exec(\n  (filter: FilterType) => (state: TodoState): TodoState => ({\n    ...state,\n    filter,\n  }),\n  [/* no dependencies - pure action */]\n);\n// Action: Clear completed todos\nexport const clearCompleted = exec(\n  () => (state: TodoState): TodoState => ({\n    ...state,\n    todos: state.todos.filter(todo => !todo.completed),\n  }),\n  [/* no dependencies - pure action */]\n);","create-react-components#Create React Components":"","main-app-component#Main App Component":"// src/App.tsx\nimport React from 'react';\nimport { ScopeProvider } from '@pumped-fn/react';\nimport { TodoList } from './components/TodoList';\nimport { TodoForm } from './components/TodoForm';\nimport { TodoFilters } from './components/TodoFilters';\nimport { TodoStats } from './components/TodoStats';\nimport './App.css';\nfunction App() {\n  return (\n    <ScopeProvider>\n      <div className=\"app\">\n        <header className=\"app-header\">\n          <h1>Todo App</h1>\n          <TodoStats />\n        </header>\n        \n        <main className=\"app-main\">\n          <TodoForm />\n          <TodoFilters />\n          <TodoList />\n        </main>\n      </div>\n    </ScopeProvider>\n  );\n}\nexport default App;","todo-form-component#Todo Form Component":"// src/components/TodoForm.tsx\nimport React, { useState } from 'react';\nimport { useUpdate } from '@pumped-fn/react';\nimport { todoState } from '../executors/todos';\nimport { addTodo } from '../executors/actions';\nexport function TodoForm() {\n  const [text, setText] = useState('');\n  const updateTodoState = useUpdate(todoState);\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (text.trim()) {\n      updateTodoState(addTodo(text.trim()));\n      setText('');\n    }\n  };\n  return (\n    <form onSubmit={handleSubmit} className=\"todo-form\">\n      <input\n        type=\"text\"\n        value={text}\n        onChange={(e) => setText(e.target.value)}\n        placeholder=\"What needs to be done?\"\n        className=\"todo-input\"\n      />\n      <button type=\"submit\" disabled={!text.trim()}>\n        Add Todo\n      </button>\n    </form>\n  );\n}","todo-list-component#Todo List Component":"// src/components/TodoList.tsx\nimport React from 'react';\nimport { useResolves, useUpdate } from '@pumped-fn/react';\nimport { filteredTodos, todoState } from '../executors/todos';\nimport { toggleTodo, removeTodo } from '../executors/actions';\nimport { TodoItem } from './TodoItem';\nexport function TodoList() {\n  const [todos] = useResolves(filteredTodos);\n  const updateTodoState = useUpdate(todoState);\n  const handleToggle = (id: string) => {\n    updateTodoState(toggleTodo(id));\n  };\n  const handleRemove = (id: string) => {\n    updateTodoState(removeTodo(id));\n  };\n  if (todos.length === 0) {\n    return (\n      <div className=\"empty-state\">\n        <p>No todos yet. Add one above!</p>\n      </div>\n    );\n  }\n  return (\n    <ul className=\"todo-list\">\n      {todos.map(todo => (\n        <TodoItem\n          key={todo.id}\n          todo={todo}\n          onToggle={handleToggle}\n          onRemove={handleRemove}\n        />\n      ))}\n    </ul>\n  );\n}","todo-item-component#Todo Item Component":"// src/components/TodoItem.tsx\nimport React from 'react';\nimport { Todo } from '../types';\ninterface TodoItemProps {\n  todo: Todo;\n  onToggle: (id: string) => void;\n  onRemove: (id: string) => void;\n}\nexport function TodoItem({ todo, onToggle, onRemove }: TodoItemProps) {\n  return (\n    <li className={`todo-item ${todo.completed ? 'completed' : ''}`}>\n      <label className=\"todo-label\">\n        <input\n          type=\"checkbox\"\n          checked={todo.completed}\n          onChange={() => onToggle(todo.id)}\n        />\n        <span className=\"todo-text\">{todo.text}</span>\n      </label>\n      \n      <button\n        onClick={() => onRemove(todo.id)}\n        className=\"todo-remove\"\n        aria-label=\"Remove todo\"\n      >\n        Ã—\n      </button>\n    </li>\n  );\n}","filter-component#Filter Component":"// src/components/TodoFilters.tsx\nimport React from 'react';\nimport { useResolves, useUpdate } from '@pumped-fn/react';\nimport { todoState } from '../executors/todos';\nimport { setFilter, clearCompleted } from '../executors/actions';\nimport { FilterType } from '../types';\nexport function TodoFilters() {\n  const [state] = useResolves(todoState);\n  const updateTodoState = useUpdate(todoState);\n  const handleFilterChange = (filter: FilterType) => {\n    updateTodoState(setFilter(filter));\n  };\n  const handleClearCompleted = () => {\n    updateTodoState(clearCompleted());\n  };\n  const hasCompleted = state.todos.some(todo => todo.completed);\n  return (\n    <div className=\"todo-filters\">\n      <div className=\"filter-buttons\">\n        {(['all', 'active', 'completed'] as FilterType[]).map(filter => (\n          <button\n            key={filter}\n            onClick={() => handleFilterChange(filter)}\n            className={`filter-button ${state.filter === filter ? 'active' : ''}`}\n          >\n            {filter.charAt(0).toUpperCase() + filter.slice(1)}\n          </button>\n        ))}\n      </div>\n      \n      {hasCompleted && (\n        <button\n          onClick={handleClearCompleted}\n          className=\"clear-completed\"\n        >\n          Clear Completed\n        </button>\n      )}\n    </div>\n  );\n}","stats-component#Stats Component":"// src/components/TodoStats.tsx\nimport React from 'react';\nimport { useResolves } from '@pumped-fn/react';\nimport { todoStats } from '../executors/todos';\nexport function TodoStats() {\n  const [stats] = useResolves(todoStats);\n  if (stats.total === 0) {\n    return null;\n  }\n  return (\n    <div className=\"todo-stats\">\n      <span className=\"stat\">\n        <strong>{stats.active}</strong> active\n      </span>\n      <span className=\"stat\">\n        <strong>{stats.completed}</strong> completed\n      </span>\n      <span className=\"stat\">\n        <strong>{stats.total}</strong> total\n      </span>\n    </div>\n  );\n}","add-persistence#Add Persistence":"Make the todos persist across browser sessions:\n// src/executors/persistence.ts\nimport { exec } from '@pumped-fn/core-next';\nimport { TodoState } from '../types';\nconst STORAGE_KEY = 'pumped-fn-todos';\n// Executor to load initial state from localStorage\nexport const loadInitialState = exec((): TodoState => {\n  try {\n    const saved = localStorage.getItem(STORAGE_KEY);\n    if (saved) {\n      const parsed = JSON.parse(saved);\n      // Convert date strings back to Date objects\n      return {\n        ...parsed,\n        todos: parsed.todos.map((todo: any) => ({\n          ...todo,\n          createdAt: new Date(todo.createdAt),\n        })),\n      };\n    }\n  } catch (error) {\n    console.warn('Failed to load todos from localStorage:', error);\n  }\n  \n  return {\n    todos: [],\n    filter: 'all',\n  };\n});\n// Executor to save state to localStorage\nexport const saveState = exec(\n  (state: TodoState) => {\n    try {\n      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));\n    } catch (error) {\n      console.warn('Failed to save todos to localStorage:', error);\n    }\n  },\n  [/* no dependencies - side effect */]\n);\nUpdate the todo state executor to use persistence:\n// src/executors/todos.ts (updated)\nimport { exec } from '@pumped-fn/core-next';\nimport { Todo, TodoState, FilterType } from '../types';\nimport { loadInitialState, saveState } from './persistence';\n// Core state executor with persistence\nexport const todoState = exec(\n  (initialState: TodoState): TodoState => initialState,\n  loadInitialState\n);\n// Add a side effect to save state on changes\nexport const persistTodos = exec(\n  (state: TodoState) => {\n    saveState(state);\n    return state;\n  },\n  todoState.reactive\n);\n// ... rest of the executors remain the same\nAdd the persistence effect to your App component:\n// src/App.tsx (updated)\nimport React from 'react';\nimport { ScopeProvider } from '@pumped-fn/react';\nimport { Effect } from '@pumped-fn/react';\nimport { persistTodos } from './executors/todos';\n// ... other imports\nfunction App() {\n  return (\n    <ScopeProvider>\n      <Effect e={[persistTodos]} />\n      <div className=\"app\">\n        {/* ... rest of your app */}\n      </div>\n    </ScopeProvider>\n  );\n}","add-styling#Add Styling":"Add some CSS to make it look good:\n/* src/App.css */\n.app {\n  max-width: 600px;\n  margin: 0 auto;\n  padding: 20px;\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;\n}\n.app-header {\n  text-align: center;\n  margin-bottom: 30px;\n}\n.app-header h1 {\n  color: #333;\n  margin-bottom: 10px;\n}\n.todo-stats {\n  display: flex;\n  gap: 20px;\n  justify-content: center;\n  color: #666;\n  font-size: 14px;\n}\n.todo-form {\n  display: flex;\n  gap: 10px;\n  margin-bottom: 20px;\n}\n.todo-input {\n  flex: 1;\n  padding: 12px;\n  border: 2px solid #ddd;\n  border-radius: 4px;\n  font-size: 16px;\n}\n.todo-input:focus {\n  outline: none;\n  border-color: #007bff;\n}\n.todo-filters {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  margin-bottom: 20px;\n  padding: 10px;\n  background: #f8f9fa;\n  border-radius: 4px;\n}\n.filter-buttons {\n  display: flex;\n  gap: 5px;\n}\n.filter-button {\n  padding: 5px 10px;\n  border: 1px solid #ddd;\n  background: white;\n  cursor: pointer;\n  border-radius: 3px;\n}\n.filter-button.active {\n  background: #007bff;\n  color: white;\n  border-color: #007bff;\n}\n.clear-completed {\n  padding: 5px 10px;\n  background: #dc3545;\n  color: white;\n  border: none;\n  border-radius: 3px;\n  cursor: pointer;\n}\n.todo-list {\n  list-style: none;\n  padding: 0;\n}\n.todo-item {\n  display: flex;\n  align-items: center;\n  padding: 10px;\n  border: 1px solid #eee;\n  margin-bottom: 5px;\n  border-radius: 4px;\n}\n.todo-item.completed {\n  opacity: 0.6;\n}\n.todo-label {\n  display: flex;\n  align-items: center;\n  flex: 1;\n  cursor: pointer;\n}\n.todo-text {\n  margin-left: 10px;\n}\n.todo-item.completed .todo-text {\n  text-decoration: line-through;\n}\n.todo-remove {\n  background: none;\n  border: none;\n  font-size: 18px;\n  cursor: pointer;\n  color: #dc3545;\n  padding: 5px;\n}\n.empty-state {\n  text-align: center;\n  padding: 40px;\n  color: #666;\n}","testing-your-app#Testing Your App":"Create tests for your executors:\n// src/__tests__/todos.test.ts\nimport { describe, it, expect } from 'vitest';\nimport { createScope } from '@pumped-fn/core-next';\nimport { todoState, filteredTodos, todoStats } from '../executors/todos';\nimport { addTodo, toggleTodo, setFilter } from '../executors/actions';\ndescribe('Todo App', () => {\n  it('should add todos', () => {\n    const scope = createScope();\n    \n    // Add a todo\n    scope.update(todoState, addTodo('Learn Pumped Functions'));\n    \n    const state = scope.resolve(todoState);\n    expect(state.todos).toHaveLength(1);\n    expect(state.todos[0].text).toBe('Learn Pumped Functions');\n    expect(state.todos[0].completed).toBe(false);\n  });\n  it('should toggle todos', () => {\n    const scope = createScope();\n    \n    // Add and toggle a todo\n    scope.update(todoState, addTodo('Test todo'));\n    const state = scope.resolve(todoState);\n    const todoId = state.todos[0].id;\n    \n    scope.update(todoState, toggleTodo(todoId));\n    \n    const updatedState = scope.resolve(todoState);\n    expect(updatedState.todos[0].completed).toBe(true);\n  });\n  it('should filter todos', () => {\n    const scope = createScope();\n    \n    // Add some todos\n    scope.update(todoState, addTodo('Active todo'));\n    scope.update(todoState, addTodo('Completed todo'));\n    \n    const state = scope.resolve(todoState);\n    const completedTodoId = state.todos[1].id;\n    \n    // Complete one todo\n    scope.update(todoState, toggleTodo(completedTodoId));\n    \n    // Test active filter\n    scope.update(todoState, setFilter('active'));\n    const activeTodos = scope.resolve(filteredTodos);\n    expect(activeTodos).toHaveLength(1);\n    expect(activeTodos[0].text).toBe('Active todo');\n    \n    // Test completed filter\n    scope.update(todoState, setFilter('completed'));\n    const completedTodos = scope.resolve(filteredTodos);\n    expect(completedTodos).toHaveLength(1);\n    expect(completedTodos[0].text).toBe('Completed todo');\n  });\n  it('should calculate stats', () => {\n    const scope = createScope();\n    \n    // Add some todos\n    scope.update(todoState, addTodo('Todo 1'));\n    scope.update(todoState, addTodo('Todo 2'));\n    scope.update(todoState, addTodo('Todo 3'));\n    \n    const state = scope.resolve(todoState);\n    const todoId = state.todos[0].id;\n    \n    // Complete one todo\n    scope.update(todoState, toggleTodo(todoId));\n    \n    const stats = scope.resolve(todoStats);\n    expect(stats.total).toBe(3);\n    expect(stats.completed).toBe(1);\n    expect(stats.active).toBe(2);\n  });\n});","run-your-app#Run Your App":"Start the development server:\npnpm start\nYour todo app is now running with:\nâœ… Reactive state management\nâœ… Type-safe operations\nâœ… Persistent storage\nâœ… Filtered views\nâœ… Real-time updates\nâœ… Comprehensive testing","key-patterns-youve-learned#Key Patterns You've Learned":"State Management: Using executors for centralized state\nDerived State: Computing values from other executors reactively\nActions: Pure functions that return state updaters\nReact Integration: Using hooks to connect executors to components\nSide Effects: Handling persistence and other side effects\nTesting: Writing tests for executor-based applications","next-steps#Next Steps":"Now that you've built your first app, explore:\nCore Concepts - Deep dive into advanced patterns\nReact Integration - More React-specific features\nTesting - Advanced testing strategies\nExamples - More example applications\nCongratulations! You've built a complete application with Pumped Functions. The patterns you've learned here will scale to much larger applications."}},"/react/overview":{"title":"React Integration","data":{"":"Pumped Functions provides seamless React integration through hooks and components that make it easy to use executors in React applications. The integration leverages React's concurrent features for optimal performance.","installation#Installation":"pnpm add @pumped-fn/react\nThe React package requires @pumped-fn/core-next and react as peer dependencies.","core-concepts#Core Concepts":"","scopeprovider#ScopeProvider":"The ScopeProvider creates a scope context that all child components can access:\nimport { ScopeProvider } from '@pumped-fn/react';\nfunction App() {\n  return (\n    <ScopeProvider>\n      <MyComponent />\n    </ScopeProvider>\n  );\n}","useresolves-hook#useResolves Hook":"The primary hook for resolving executors in React components:\nimport { useResolves } from '@pumped-fn/react';\nfunction MyComponent() {\n  const [userData, config] = useResolves(userExecutor, configExecutor);\n  \n  return (\n    <div>\n      <h1>Welcome {userData.name}!</h1>\n      <p>API URL: {config.apiUrl}</p>\n    </div>\n  );\n}","essential-hooks#Essential Hooks":"","useresolves#useResolves":"Resolve multiple executors at once:\nimport { useResolves } from '@pumped-fn/react';\nfunction Dashboard() {\n  const [user, notifications, settings] = useResolves(\n    userExecutor,\n    notificationsExecutor,\n    settingsExecutor\n  );\n  return (\n    <div>\n      <h1>Welcome {user.name}!</h1>\n      <p>You have {notifications.length} notifications</p>\n      <p>Theme: {settings.theme}</p>\n    </div>\n  );\n}","useresolve-with-selector#useResolve with Selector":"For performance optimization, use selectors to subscribe to specific parts of the state:\nimport { useResolve } from '@pumped-fn/react';\nfunction UserName() {\n  const userName = useResolve(\n    userExecutor,\n    (user) => user.name  // Selector function\n  );\n  return <span>{userName}</span>;\n}\n// With equality check\nfunction UserEmail() {\n  const userEmail = useResolve(\n    userExecutor,\n    (user) => user.email,\n    {\n      equality: (a, b) => a === b,  // Custom equality\n      snapshot: (email) => email,   // Snapshot for stability\n    }\n  );\n  return <span>{userEmail}</span>;\n}","useupdate#useUpdate":"Update executor values from React components:\nimport { useUpdate } from '@pumped-fn/react';\nfunction Counter() {\n  const [count] = useResolves(counterExecutor);\n  const updateCounter = useUpdate(counterExecutor);\n  const increment = () => {\n    updateCounter((current) => ({ count: current.count + 1 }));\n  };\n  const reset = () => {\n    updateCounter({ count: 0 });\n  };\n  return (\n    <div>\n      <p>Count: {count.count}</p>\n      <button onClick={increment}>Increment</button>\n      <button onClick={reset}>Reset</button>\n    </div>\n  );\n}","usescope#useScope":"Access the current scope directly:\nimport { useScope } from '@pumped-fn/react';\nfunction AdvancedComponent() {\n  const scope = useScope();\n  const handleManualResolve = () => {\n    const value = scope.resolve(someExecutor);\n    console.log('Manually resolved:', value);\n  };\n  return (\n    <button onClick={handleManualResolve}>\n      Manual Resolve\n    </button>\n  );\n}","userelease#useRelease":"Release an executor and clean up its resources:\nimport { useRelease } from '@pumped-fn/react';\nfunction ResourceManager() {\n  const [resource] = useResolves(expensiveResourceExecutor);\n  const releaseResource = useRelease(expensiveResourceExecutor);\n  const cleanup = () => {\n    releaseResource();\n  };\n  return (\n    <div>\n      <p>Resource: {resource.name}</p>\n      <button onClick={cleanup}>Cleanup</button>\n    </div>\n  );\n}","react-components#React Components":"","scopeprovider-1#ScopeProvider":"Create and manage scopes:\nimport { ScopeProvider, createScope } from '@pumped-fn/react';\n// Basic usage\nfunction App() {\n  return (\n    <ScopeProvider>\n      <Dashboard />\n    </ScopeProvider>\n  );\n}\n// With custom scope\nfunction AppWithCustomScope() {\n  const customScope = createScope();\n  \n  return (\n    <ScopeProvider scope={customScope}>\n      <Dashboard />\n    </ScopeProvider>\n  );\n}\n// With presets\nfunction AppWithPresets() {\n  const presets = [\n    { executor: configExecutor, value: defaultConfig },\n    { executor: userExecutor, value: guestUser },\n  ];\n  \n  return (\n    <ScopeProvider presets={presets}>\n      <Dashboard />\n    </ScopeProvider>\n  );\n}","resolves-component#Resolves Component":"Render props pattern for resolving executors:\nimport { Resolves } from '@pumped-fn/react';\nfunction UserProfile() {\n  return (\n    <Resolves e={[userExecutor, settingsExecutor]}>\n      {([user, settings]) => (\n        <div>\n          <h1>{user.name}</h1>\n          <p>Theme: {settings.theme}</p>\n        </div>\n      )}\n    </Resolves>\n  );\n}","reselect-component#Reselect Component":"Render props with selector:\nimport { Reselect } from '@pumped-fn/react';\nfunction UserName() {\n  return (\n    <Reselect \n      e={userExecutor}\n      selector={(user) => user.name}\n    >\n      {(name) => <h1>Hello {name}!</h1>}\n    </Reselect>\n  );\n}","reactives-component#Reactives Component":"Automatically make executors reactive:\nimport { Reactives } from '@pumped-fn/react';\nfunction ReactiveDisplay() {\n  return (\n    <Reactives e={[counterExecutor, timerExecutor]}>\n      {([counter, timer]) => (\n        <div>\n          <p>Count: {counter.count}</p>\n          <p>Time: {timer.seconds}</p>\n        </div>\n      )}\n    </Reactives>\n  );\n}","effect-component#Effect Component":"Handle side effects:\nimport { Effect } from '@pumped-fn/react';\nfunction App() {\n  return (\n    <div>\n      <Effect e={[loggingExecutor, analyticsExecutor]} />\n      <MainContent />\n    </div>\n  );\n}","reactive-programming#Reactive Programming":"","automatic-updates#Automatic Updates":"React components automatically re-render when reactive executors change:\nconst counter = exec(() => ({ count: 0 }));\nconst doubled = exec(\n  (state) => state.count * 2,\n  counter.reactive  // This makes it reactive\n);\nfunction ReactiveCounter() {\n  const [count, doubledValue] = useResolves(counter, doubled);\n  const updateCounter = useUpdate(counter);\n  // When counter updates, doubled automatically updates too\n  return (\n    <div>\n      <p>Count: {count.count}</p>\n      <p>Doubled: {doubledValue}</p>\n      <button onClick={() => updateCounter(c => ({ count: c.count + 1 }))}>\n        Increment\n      </button>\n    </div>\n  );\n}","concurrent-features#Concurrent Features":"The React integration uses React's concurrent features for optimal performance:\nimport { startTransition } from 'react';\nfunction OptimizedComponent() {\n  const [data] = useResolves(dataExecutor);\n  const updateData = useUpdate(dataExecutor);\n  const handleUpdate = () => {\n    startTransition(() => {\n      updateData(newData);\n    });\n  };\n  return (\n    <div>\n      <DisplayData data={data} />\n      <button onClick={handleUpdate}>Update</button>\n    </div>\n  );\n}","advanced-patterns#Advanced Patterns":"","conditional-rendering#Conditional Rendering":"function ConditionalApp() {\n  const [user] = useResolves(userExecutor);\n  \n  if (!user) {\n    return <LoginForm />;\n  }\n  return (\n    <ScopeProvider>\n      <UserDashboard />\n    </ScopeProvider>\n  );\n}","error-boundaries#Error Boundaries":"Handle errors from executors:\nimport { ErrorBoundary } from 'react-error-boundary';\nfunction ErrorFallback({ error }) {\n  return (\n    <div role=\"alert\">\n      <h2>Something went wrong:</h2>\n      <pre>{error.message}</pre>\n    </div>\n  );\n}\nfunction App() {\n  return (\n    <ErrorBoundary FallbackComponent={ErrorFallback}>\n      <ScopeProvider>\n        <Dashboard />\n      </ScopeProvider>\n    </ErrorBoundary>\n  );\n}","suspense-integration#Suspense Integration":"Handle async executors with Suspense:\nimport { Suspense } from 'react';\nfunction AsyncComponent() {\n  const [data] = useResolves(asyncDataExecutor);\n  \n  return <div>{data.content}</div>;\n}\nfunction App() {\n  return (\n    <ScopeProvider>\n      <Suspense fallback={<div>Loading...</div>}>\n        <AsyncComponent />\n      </Suspense>\n    </ScopeProvider>\n  );\n}","performance-optimization#Performance Optimization":"","selective-updates#Selective Updates":"Use selectors to limit re-renders:\n// Only re-renders when user.name changes\nfunction UserName() {\n  const name = useResolve(userExecutor, (user) => user.name);\n  return <h1>{name}</h1>;\n}\n// Only re-renders when user.email changes\nfunction UserEmail() {\n  const email = useResolve(userExecutor, (user) => user.email);\n  return <p>{email}</p>;\n}","memoization#Memoization":"Combine with React.memo for optimal performance:\nimport { memo } from 'react';\nconst UserCard = memo(function UserCard({ userId }) {\n  const user = useResolve(\n    userExecutor,\n    (users) => users.find(u => u.id === userId)\n  );\n  return (\n    <div>\n      <h3>{user.name}</h3>\n      <p>{user.email}</p>\n    </div>\n  );\n});","lazy-loading#Lazy Loading":"Use lazy executors for performance:\nfunction LazyComponent() {\n  const [data] = useResolves(\n    expensiveDataExecutor.lazy  // Only loads when needed\n  );\n  return <ExpensiveView data={data} />;\n}","testing-with-react-testing-library#Testing with React Testing Library":"import { render, screen } from '@testing-library/react';\nimport { ScopeProvider } from '@pumped-fn/react';\nimport { exec } from '@pumped-fn/core-next';\n// Mock executors for testing\nconst mockUser = exec(() => ({ name: 'Test User', email: 'test@example.com' }));\ntest('renders user information', () => {\n  render(\n    <ScopeProvider>\n      <UserProfile />\n    </ScopeProvider>\n  );\n  expect(screen.getByText('Test User')).toBeInTheDocument();\n  expect(screen.getByText('test@example.com')).toBeInTheDocument();\n});","server-side-rendering#Server-Side Rendering":"Pumped Functions works with SSR:\nimport { ScopeProvider, createScope } from '@pumped-fn/react';\n// Server-side\nexport async function getServerSideProps() {\n  const scope = createScope();\n  \n  // Pre-resolve data on server\n  const userData = await scope.resolve(userDataExecutor);\n  \n  return {\n    props: {\n      initialData: userData,\n    },\n  };\n}\n// Client-side\nfunction App({ initialData }) {\n  const scope = createScope();\n  \n  // Hydrate with server data\n  scope.update(userDataExecutor, initialData);\n  return (\n    <ScopeProvider scope={scope}>\n      <Dashboard />\n    </ScopeProvider>\n  );\n}","best-practices#Best Practices":"","1-keep-components-simple#1. Keep Components Simple":"Let executors handle the logic:\n// Good - logic in executor\nconst userStats = exec(\n  (user) => ({\n    totalPosts: user.posts.length,\n    totalLikes: user.posts.reduce((sum, p) => sum + p.likes, 0),\n  }),\n  userExecutor.reactive\n);\nfunction UserStats() {\n  const [stats] = useResolves(userStats);\n  return <div>Posts: {stats.totalPosts}, Likes: {stats.totalLikes}</div>;\n}","2-use-appropriate-hooks#2. Use Appropriate Hooks":"Choose the right hook for your use case:\n// For multiple values\nconst [user, settings] = useResolves(userExecutor, settingsExecutor);\n// For single value with selector\nconst userName = useResolve(userExecutor, (user) => user.name);\n// For updates\nconst updateUser = useUpdate(userExecutor);","3-handle-loading-states#3. Handle Loading States":"function UserProfile() {\n  const [user] = useResolves(userExecutor);\n  \n  if (!user) {\n    return <div>Loading...</div>;\n  }\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>{user.email}</p>\n    </div>\n  );\n}","common-pitfalls#Common Pitfalls":"","1-dont-create-executors-in-render#1. Don't Create Executors in Render":"// Don't do this\nfunction BadComponent() {\n  const badExecutor = exec(() => Math.random()); // New executor every render!\n  const [value] = useResolves(badExecutor);\n  return <div>{value}</div>;\n}\n// Do this instead\nconst goodExecutor = exec(() => Math.random());\nfunction GoodComponent() {\n  const [value] = useResolves(goodExecutor);\n  return <div>{value}</div>;\n}","2-avoid-unnecessary-reactive-dependencies#2. Avoid Unnecessary Reactive Dependencies":"// Less efficient - entire state is reactive\nconst userDisplayName = exec(\n  (appState) => appState.user.name,\n  appStateExecutor.reactive\n);\n// More efficient - specific reactive dependency\nconst userDisplayName = exec(\n  (user) => user.name,\n  userExecutor.reactive\n);","next-steps#Next Steps":"Testing - Learn how to test React components with executors\nExamples - See complete React examples\nCore Concepts - Deep dive into executor patterns\nThe React integration makes it easy to build reactive, performant applications with Pumped Functions. The hooks and components provide a natural way to connect your executor-based logic to React's component model."}},"/testing/overview":{"title":"Testing Overview","data":{"":"Pumped Functions is designed with testing in mind. The functional, dependency-injected architecture makes it easy to test your application logic in isolation, mock dependencies, and verify behavior.","why-testing-is-easy#Why Testing is Easy":"","1-pure-functions#1. Pure Functions":"Executors are typically pure functions, making them predictable and easy to test:\nimport { exec } from '@pumped-fn/core-next';\nconst calculateTotal = exec(\n  (items: Item[]) => items.reduce((sum, item) => sum + item.price, 0),\n  itemsExecutor\n);\n// Easy to test - pure function behavior","2-dependency-injection#2. Dependency Injection":"Dependencies are explicitly declared, making mocking straightforward:\nconst userService = exec(\n  (api: ApiClient, logger: Logger) => new UserService(api, logger),\n  [apiClient, logger]\n);\n// Easy to test - mock the dependencies","3-isolated-scopes#3. Isolated Scopes":"Each test can have its own scope, preventing test interference:\nimport { createScope } from '@pumped-fn/core-next';\ntest('isolated test', () => {\n  const scope = createScope(); // Fresh scope per test\n  // Test logic here\n});","testing-setup#Testing Setup":"","installation#Installation":"# Using Vitest (recommended)\npnpm add -D vitest\n# Or using Jest\npnpm add -D jest @types/jest\n# For React testing\npnpm add -D @testing-library/react @testing-library/jest-dom","configuration#Configuration":"Vitest configuration (vitest.config.ts):\nimport { defineConfig } from 'vitest/config';\nexport default defineConfig({\n  test: {\n    environment: 'jsdom', // For React testing\n    setupFiles: ['./src/test/setup.ts'],\n  },\n});\nTest setup (src/test/setup.ts):\nimport '@testing-library/jest-dom';","testing-strategies#Testing Strategies":"","1-unit-testing#1. Unit Testing":"Test individual executors in isolation:\nimport { describe, it, expect } from 'vitest';\nimport { exec, createScope } from '@pumped-fn/core-next';\ndescribe('Calculator', () => {\n  it('should add two numbers', () => {\n    const a = exec(() => 5);\n    const b = exec(() => 3);\n    const sum = exec((a: number, b: number) => a + b, [a, b]);\n    const scope = createScope();\n    const result = scope.resolve(sum);\n    expect(result).toBe(8);\n  });\n});","2-integration-testing#2. Integration Testing":"Test how executors work together:\ndescribe('User Profile Integration', () => {\n  it('should create complete user profile', () => {\n    const userData = exec(() => ({ name: 'John', email: 'john@example.com' }));\n    const preferences = exec(() => ({ theme: 'dark', lang: 'en' }));\n    \n    const profile = exec(\n      (user, prefs) => ({ ...user, ...prefs }),\n      [userData, preferences]\n    );\n    const scope = createScope();\n    const result = scope.resolve(profile);\n    expect(result).toEqual({\n      name: 'John',\n      email: 'john@example.com',\n      theme: 'dark',\n      lang: 'en',\n    });\n  });\n});","3-reactive-testing#3. Reactive Testing":"Test reactive behavior:\ndescribe('Reactive Updates', () => {\n  it('should update derived values when source changes', () => {\n    const counter = exec(() => ({ count: 0 }));\n    const doubled = exec(\n      (state) => state.count * 2,\n      counter.reactive\n    );\n    const scope = createScope();\n    \n    // Initial state\n    expect(scope.resolve(doubled)).toBe(0);\n    \n    // Update source\n    scope.update(counter, { count: 5 });\n    \n    // Derived value should update\n    expect(scope.resolve(doubled)).toBe(10);\n  });\n});","testing-patterns#Testing Patterns":"","mock-dependencies#Mock Dependencies":"Replace dependencies with mocks:\nimport { vi } from 'vitest';\ndescribe('UserService', () => {\n  it('should fetch user data', async () => {\n    // Mock API client\n    const mockApiClient = exec(() => ({\n      getUser: vi.fn().mockResolvedValue({ id: 1, name: 'John' }),\n    }));\n    const userService = exec(\n      (api) => ({\n        fetchUser: (id: number) => api.getUser(id),\n      }),\n      mockApiClient\n    );\n    const scope = createScope();\n    const service = scope.resolve(userService);\n    \n    const user = await service.fetchUser(1);\n    expect(user).toEqual({ id: 1, name: 'John' });\n  });\n});","test-factories#Test Factories":"Create reusable test data:\n// test/factories.ts\nexport const createUser = (overrides = {}) => ({\n  id: 1,\n  name: 'Test User',\n  email: 'test@example.com',\n  ...overrides,\n});\nexport const createUserExecutor = (user = {}) => \n  exec(() => createUser(user));\n// In tests\ndescribe('User Profile', () => {\n  it('should display user name', () => {\n    const user = createUserExecutor({ name: 'Custom Name' });\n    const scope = createScope();\n    \n    const result = scope.resolve(user);\n    expect(result.name).toBe('Custom Name');\n  });\n});","async-testing#Async Testing":"Test async executors:\ndescribe('Async Operations', () => {\n  it('should handle async data fetching', async () => {\n    const asyncData = exec(async () => {\n      await new Promise(resolve => setTimeout(resolve, 10));\n      return { data: 'async result' };\n    });\n    const scope = createScope();\n    const result = await scope.resolve(asyncData);\n    expect(result.data).toBe('async result');\n  });\n  it('should handle errors', async () => {\n    const failingExecutor = exec(async () => {\n      throw new Error('Network error');\n    });\n    const scope = createScope();\n    \n    await expect(scope.resolve(failingExecutor))\n      .rejects\n      .toThrow('Network error');\n  });\n});","state-testing#State Testing":"Test state updates:\ndescribe('State Management', () => {\n  it('should update state correctly', () => {\n    const state = exec(() => ({ count: 0, name: 'initial' }));\n    const scope = createScope();\n    // Initial state\n    expect(scope.resolve(state)).toEqual({ count: 0, name: 'initial' });\n    // Update with function\n    scope.update(state, (current) => ({ ...current, count: current.count + 1 }));\n    expect(scope.resolve(state).count).toBe(1);\n    // Update with value\n    scope.update(state, { count: 5, name: 'updated' });\n    expect(scope.resolve(state)).toEqual({ count: 5, name: 'updated' });\n  });\n});","testing-best-practices#Testing Best Practices":"","1-arrange-act-assert-pattern#1. Arrange-Act-Assert Pattern":"Structure your tests clearly:\ndescribe('Calculator', () => {\n  it('should calculate percentage', () => {\n    // Arrange\n    const value = exec(() => 200);\n    const percentage = exec(() => 15);\n    const result = exec(\n      (val: number, pct: number) => (val * pct) / 100,\n      [value, percentage]\n    );\n    const scope = createScope();\n    // Act\n    const calculation = scope.resolve(result);\n    // Assert\n    expect(calculation).toBe(30);\n  });\n});","2-test-behavior-not-implementation#2. Test Behavior, Not Implementation":"Focus on what the executor does, not how:\n// Good - tests behavior\nit('should format user display name', () => {\n  const user = exec(() => ({ firstName: 'John', lastName: 'Doe' }));\n  const displayName = exec(\n    (user) => `${user.firstName} ${user.lastName}`,\n    user\n  );\n  const scope = createScope();\n  const result = scope.resolve(displayName);\n  expect(result).toBe('John Doe');\n});","3-use-descriptive-test-names#3. Use Descriptive Test Names":"Make your tests self-documenting:\ndescribe('User Authentication', () => {\n  it('should return true when user has valid token', () => {\n    // Test implementation\n  });\n  it('should return false when token is expired', () => {\n    // Test implementation\n  });\n  it('should throw error when token is malformed', () => {\n    // Test implementation\n  });\n});","4-group-related-tests#4. Group Related Tests":"Organize tests with describe blocks:\ndescribe('ShoppingCart', () => {\n  describe('adding items', () => {\n    it('should add item to empty cart', () => {\n      // Test implementation\n    });\n    it('should increment quantity for existing item', () => {\n      // Test implementation\n    });\n  });\n  describe('removing items', () => {\n    it('should remove item completely', () => {\n      // Test implementation\n    });\n    it('should decrement quantity', () => {\n      // Test implementation\n    });\n  });\n});","advanced-testing-techniques#Advanced Testing Techniques":"","property-based-testing#Property-Based Testing":"Use libraries like fast-check for property-based testing:\nimport fc from 'fast-check';\ndescribe('Math Operations', () => {\n  it('should be commutative for addition', () => {\n    fc.assert(\n      fc.property(fc.integer(), fc.integer(), (a, b) => {\n        const sum1 = exec((a: number, b: number) => a + b, [exec(() => a), exec(() => b)]);\n        const sum2 = exec((a: number, b: number) => a + b, [exec(() => b), exec(() => a)]);\n        \n        const scope = createScope();\n        return scope.resolve(sum1) === scope.resolve(sum2);\n      })\n    );\n  });\n});","snapshot-testing#Snapshot Testing":"Test complex output structures:\ndescribe('Configuration', () => {\n  it('should generate correct config structure', () => {\n    const config = exec(() => ({\n      api: { url: 'https://api.example.com', timeout: 5000 },\n      features: { newUI: true, analytics: false },\n      theme: { mode: 'dark', colors: ['#000', '#fff'] },\n    }));\n    const scope = createScope();\n    const result = scope.resolve(config);\n    expect(result).toMatchSnapshot();\n  });\n});","performance-testing#Performance Testing":"Test performance characteristics:\ndescribe('Performance', () => {\n  it('should resolve large dependency tree efficiently', () => {\n    const executors = Array.from({ length: 1000 }, (_, i) => \n      exec(() => i)\n    );\n    \n    const combined = exec(\n      (...values: number[]) => values.reduce((sum, val) => sum + val, 0),\n      executors\n    );\n    const scope = createScope();\n    const start = performance.now();\n    \n    const result = scope.resolve(combined);\n    \n    const end = performance.now();\n    const duration = end - start;\n    expect(result).toBe(499500); // Sum of 0 to 999\n    expect(duration).toBeLessThan(100); // Should be fast\n  });\n});","common-testing-patterns#Common Testing Patterns":"","test-data-builders#Test Data Builders":"Create flexible test data:\nclass UserBuilder {\n  private user = {\n    id: 1,\n    name: 'Test User',\n    email: 'test@example.com',\n    active: true,\n  };\n  withName(name: string) {\n    this.user.name = name;\n    return this;\n  }\n  withEmail(email: string) {\n    this.user.email = email;\n    return this;\n  }\n  inactive() {\n    this.user.active = false;\n    return this;\n  }\n  build() {\n    return this.user;\n  }\n  buildExecutor() {\n    return exec(() => this.build());\n  }\n}\n// Usage\nconst user = new UserBuilder()\n  .withName('John Doe')\n  .withEmail('john@example.com')\n  .buildExecutor();","test-utilities#Test Utilities":"Create reusable test utilities:\n// test/utils.ts\nexport function createTestScope() {\n  return createScope();\n}\nexport function resolveExecutor<T>(executor: Executor<T>, scope = createTestScope()) {\n  return scope.resolve(executor);\n}\nexport function expectToResolve<T>(executor: Executor<T>, expectedValue: T) {\n  const scope = createTestScope();\n  const result = scope.resolve(executor);\n  expect(result).toEqual(expectedValue);\n}\n// Usage\nit('should calculate correctly', () => {\n  expectToResolve(calculatorExecutor, 42);\n});","next-steps#Next Steps":"Testing Executors - Deep dive into executor testing\nTesting React Components - React-specific testing patterns\nTesting Utilities - Advanced testing utilities\nInteractive Testing - Testing with user interactions\nTesting is a first-class citizen in Pumped Functions. The architecture naturally supports testing, making it easy to write comprehensive, maintainable tests for your applications."}},"/testing/testing-utilities":{"title":"Testing Utilities","data":{"":"Pumped Functions provides several testing utilities and patterns to make testing easier and more efficient. This guide covers advanced testing utilities, custom helpers, and testing strategies.","built-in-testing-utilities#Built-in Testing Utilities":"","scope-management#Scope Management":"The core testing utility is scope management for isolated tests:\nimport { createScope } from '@pumped-fn/core-next';\ndescribe('Isolated Tests', () => {\n  let scope: Scope;\n  beforeEach(() => {\n    scope = createScope();\n  });\n  it('should have fresh scope for each test', () => {\n    // Each test gets a clean scope\n    const result = scope.resolve(myExecutor);\n    expect(result).toBeDefined();\n  });\n});","executor-utilities#Executor Utilities":"Check executor types and states:\nimport { \n  isLazyExecutor, \n  isReactiveExecutor, \n  isStaticExecutor,\n  isMainExecutor \n} from '@pumped-fn/core-next';\ndescribe('Executor Type Checking', () => {\n  it('should identify executor types', () => {\n    const base = exec(() => 'value');\n    \n    expect(isMainExecutor(base)).toBe(true);\n    expect(isLazyExecutor(base.lazy)).toBe(true);\n    expect(isReactiveExecutor(base.reactive)).toBe(true);\n    expect(isStaticExecutor(base.static)).toBe(true);\n  });\n});","custom-testing-utilities#Custom Testing Utilities":"","scope-factory#Scope Factory":"Create a utility for consistent scope creation:\n// test/utils.ts\nimport { createScope, Scope } from '@pumped-fn/core-next';\nexport function createTestScope(): Scope {\n  return createScope();\n}\nexport function withScope<T>(\n  testFn: (scope: Scope) => T\n): T {\n  const scope = createTestScope();\n  return testFn(scope);\n}\n// Usage\ndescribe('Calculator', () => {\n  it('should add numbers', () => {\n    withScope((scope) => {\n      const sum = scope.resolve(sumExecutor);\n      expect(sum).toBe(8);\n    });\n  });\n});","executor-builders#Executor Builders":"Create builders for test data:\n// test/builders.ts\nimport { exec, Executor } from '@pumped-fn/core-next';\nexport class UserBuilder {\n  private data = {\n    id: '1',\n    name: 'Test User',\n    email: 'test@example.com',\n    active: true,\n    preferences: {\n      theme: 'light',\n      notifications: true,\n    },\n  };\n  withId(id: string) {\n    this.data.id = id;\n    return this;\n  }\n  withName(name: string) {\n    this.data.name = name;\n    return this;\n  }\n  withEmail(email: string) {\n    this.data.email = email;\n    return this;\n  }\n  inactive() {\n    this.data.active = false;\n    return this;\n  }\n  withTheme(theme: 'light' | 'dark') {\n    this.data.preferences.theme = theme;\n    return this;\n  }\n  build() {\n    return { ...this.data };\n  }\n  buildExecutor(): Executor<typeof this.data> {\n    return exec(() => this.build());\n  }\n}\n// Usage\ndescribe('User Profile', () => {\n  it('should display user with dark theme', () => {\n    const user = new UserBuilder()\n      .withName('John Doe')\n      .withTheme('dark')\n      .buildExecutor();\n    const scope = createTestScope();\n    const userData = scope.resolve(user);\n    \n    expect(userData.name).toBe('John Doe');\n    expect(userData.preferences.theme).toBe('dark');\n  });\n});","mock-executor-factory#Mock Executor Factory":"Create mock executors with predefined behavior:\n// test/mocks.ts\nimport { vi } from 'vitest';\nimport { exec } from '@pumped-fn/core-next';\nexport function createMockApiClient() {\n  return exec(() => ({\n    get: vi.fn(),\n    post: vi.fn(),\n    put: vi.fn(),\n    delete: vi.fn(),\n  }));\n}\nexport function createMockDatabase() {\n  const mockData = new Map();\n  \n  return exec(() => ({\n    save: vi.fn((key, value) => {\n      mockData.set(key, value);\n      return Promise.resolve(value);\n    }),\n    find: vi.fn((key) => {\n      return Promise.resolve(mockData.get(key));\n    }),\n    findAll: vi.fn(() => {\n      return Promise.resolve(Array.from(mockData.values()));\n    }),\n    delete: vi.fn((key) => {\n      mockData.delete(key);\n      return Promise.resolve();\n    }),\n  }));\n}\n// Usage\ndescribe('UserService', () => {\n  it('should save user to database', async () => {\n    const mockDb = createMockDatabase();\n    const userService = exec(\n      (db) => ({\n        saveUser: (user) => db.save(`user:${user.id}`, user),\n      }),\n      mockDb\n    );\n    const scope = createTestScope();\n    const service = scope.resolve(userService);\n    const db = scope.resolve(mockDb);\n    await service.saveUser({ id: '1', name: 'John' });\n    expect(db.save).toHaveBeenCalledWith('user:1', { id: '1', name: 'John' });\n  });\n});","testing-helpers#Testing Helpers":"","async-testing-helper#Async Testing Helper":"Helper for testing async executors:\n// test/async-helpers.ts\nimport { Executor, Scope } from '@pumped-fn/core-next';\nexport async function resolveAsync<T>(\n  executor: Executor<T>,\n  scope: Scope\n): Promise<T> {\n  return scope.resolve(executor);\n}\nexport async function expectToResolve<T>(\n  executor: Executor<T>,\n  expectedValue: T,\n  scope = createTestScope()\n): Promise<void> {\n  const result = await resolveAsync(executor, scope);\n  expect(result).toEqual(expectedValue);\n}\nexport async function expectToReject(\n  executor: Executor<any>,\n  expectedError: string | RegExp,\n  scope = createTestScope()\n): Promise<void> {\n  await expect(resolveAsync(executor, scope))\n    .rejects\n    .toThrow(expectedError);\n}\n// Usage\ndescribe('Async Operations', () => {\n  it('should resolve with correct value', async () => {\n    const asyncExecutor = exec(async () => 'async result');\n    await expectToResolve(asyncExecutor, 'async result');\n  });\n  it('should reject with error', async () => {\n    const failingExecutor = exec(async () => {\n      throw new Error('Network error');\n    });\n    await expectToReject(failingExecutor, /Network error/);\n  });\n});","reactive-testing-helper#Reactive Testing Helper":"Helper for testing reactive behavior:\n// test/reactive-helpers.ts\nimport { Executor, Scope } from '@pumped-fn/core-next';\nexport function createReactiveTest<T>(\n  reactiveExecutor: Executor<T>,\n  scope = createTestScope()\n) {\n  const values: T[] = [];\n  \n  // Subscribe to changes\n  const cleanup = scope.onUpdate(reactiveExecutor, (next) => {\n    values.push(next.get());\n  });\n  return {\n    values,\n    cleanup,\n    expectValues: (expected: T[]) => {\n      expect(values).toEqual(expected);\n    },\n    expectLastValue: (expected: T) => {\n      expect(values[values.length - 1]).toEqual(expected);\n    },\n  };\n}\n// Usage\ndescribe('Reactive Updates', () => {\n  it('should track reactive changes', () => {\n    const counter = exec(() => ({ count: 0 }));\n    const doubled = exec(\n      (state) => state.count * 2,\n      counter.reactive\n    );\n    const scope = createTestScope();\n    const test = createReactiveTest(doubled, scope);\n    // Make changes\n    scope.update(counter, { count: 1 });\n    scope.update(counter, { count: 2 });\n    scope.update(counter, { count: 3 });\n    test.expectValues([2, 4, 6]);\n    test.cleanup();\n  });\n});","state-testing-helper#State Testing Helper":"Helper for testing state management:\n// test/state-helpers.ts\nimport { Executor, Scope } from '@pumped-fn/core-next';\nexport function createStateTest<T>(\n  stateExecutor: Executor<T>,\n  scope = createTestScope()\n) {\n  return {\n    get: () => scope.resolve(stateExecutor),\n    set: (value: T) => scope.update(stateExecutor, value),\n    update: (updater: (current: T) => T) => scope.update(stateExecutor, updater),\n    expect: (expected: T) => {\n      expect(scope.resolve(stateExecutor)).toEqual(expected);\n    },\n  };\n}\n// Usage\ndescribe('State Management', () => {\n  it('should manage state correctly', () => {\n    const counter = exec(() => ({ count: 0 }));\n    const state = createStateTest(counter);\n    state.expect({ count: 0 });\n    \n    state.update(s => ({ count: s.count + 1 }));\n    state.expect({ count: 1 });\n    \n    state.set({ count: 10 });\n    state.expect({ count: 10 });\n  });\n});","test-fixtures#Test Fixtures":"","complex-test-data#Complex Test Data":"Create fixtures for complex test scenarios:\n// test/fixtures.ts\nimport { exec } from '@pumped-fn/core-next';\nexport const testUsers = [\n  { id: '1', name: 'Alice', email: 'alice@example.com', role: 'admin' },\n  { id: '2', name: 'Bob', email: 'bob@example.com', role: 'user' },\n  { id: '3', name: 'Charlie', email: 'charlie@example.com', role: 'user' },\n];\nexport const testPosts = [\n  { id: '1', title: 'First Post', authorId: '1', content: 'Content 1' },\n  { id: '2', title: 'Second Post', authorId: '2', content: 'Content 2' },\n  { id: '3', title: 'Third Post', authorId: '1', content: 'Content 3' },\n];\nexport const createTestDatabase = () => exec(() => ({\n  users: testUsers,\n  posts: testPosts,\n}));\nexport const createTestApiClient = () => exec(() => ({\n  getUsers: vi.fn().mockResolvedValue(testUsers),\n  getPosts: vi.fn().mockResolvedValue(testPosts),\n  createPost: vi.fn().mockImplementation((post) => \n    Promise.resolve({ ...post, id: String(Date.now()) })\n  ),\n}));\n// Usage\ndescribe('Blog Service', () => {\n  it('should fetch posts with authors', async () => {\n    const db = createTestDatabase();\n    const blogService = exec(\n      (database) => ({\n        getPostsWithAuthors: () => {\n          return database.posts.map(post => ({\n            ...post,\n            author: database.users.find(u => u.id === post.authorId),\n          }));\n        },\n      }),\n      db\n    );\n    const scope = createTestScope();\n    const service = scope.resolve(blogService);\n    const posts = service.getPostsWithAuthors();\n    expect(posts).toHaveLength(3);\n    expect(posts[0].author.name).toBe('Alice');\n  });\n});","environment-fixtures#Environment Fixtures":"Create different environment configurations:\n// test/environments.ts\nimport { exec } from '@pumped-fn/core-next';\nexport const developmentConfig = exec(() => ({\n  apiUrl: 'http://localhost:3000',\n  debug: true,\n  logLevel: 'debug',\n  features: {\n    newUI: true,\n    analytics: false,\n  },\n}));\nexport const productionConfig = exec(() => ({\n  apiUrl: 'https://api.production.com',\n  debug: false,\n  logLevel: 'error',\n  features: {\n    newUI: false,\n    analytics: true,\n  },\n}));\nexport const testConfig = exec(() => ({\n  apiUrl: 'http://localhost:3001',\n  debug: false,\n  logLevel: 'silent',\n  features: {\n    newUI: true,\n    analytics: false,\n  },\n}));\n// Usage\ndescribe('Feature Service', () => {\n  it('should enable new UI in development', () => {\n    const featureService = exec(\n      (config) => ({\n        isEnabled: (feature) => config.features[feature],\n      }),\n      developmentConfig\n    );\n    const scope = createTestScope();\n    const service = scope.resolve(featureService);\n    expect(service.isEnabled('newUI')).toBe(true);\n  });\n  it('should disable new UI in production', () => {\n    const featureService = exec(\n      (config) => ({\n        isEnabled: (feature) => config.features[feature],\n      }),\n      productionConfig\n    );\n    const scope = createTestScope();\n    const service = scope.resolve(featureService);\n    expect(service.isEnabled('newUI')).toBe(false);\n  });\n});","test-suites#Test Suites":"","shared-test-suites#Shared Test Suites":"Create reusable test suites:\n// test/suites.ts\nimport { Executor, Scope } from '@pumped-fn/core-next';\nexport function testCrudOperations<T>(\n  serviceExecutor: Executor<any>,\n  testData: T,\n  scope = createTestScope()\n) {\n  const service = scope.resolve(serviceExecutor);\n  describe('CRUD Operations', () => {\n    it('should create item', async () => {\n      const created = await service.create(testData);\n      expect(created).toMatchObject(testData);\n    });\n    it('should read item', async () => {\n      const created = await service.create(testData);\n      const read = await service.read(created.id);\n      expect(read).toEqual(created);\n    });\n    it('should update item', async () => {\n      const created = await service.create(testData);\n      const updated = await service.update(created.id, { ...testData, updated: true });\n      expect(updated.updated).toBe(true);\n    });\n    it('should delete item', async () => {\n      const created = await service.create(testData);\n      await service.delete(created.id);\n      const read = await service.read(created.id);\n      expect(read).toBe(null);\n    });\n  });\n}\n// Usage\ndescribe('UserService', () => {\n  testCrudOperations(\n    userServiceExecutor,\n    { name: 'Test User', email: 'test@example.com' }\n  );\n});","validation-test-suite#Validation Test Suite":"Test validation logic:\n// test/validation-suite.ts\nexport function testValidation<T>(\n  validatorExecutor: Executor<any>,\n  testCases: { input: T; expected: boolean; description: string }[]\n) {\n  describe('Validation', () => {\n    testCases.forEach(({ input, expected, description }) => {\n      it(description, () => {\n        const scope = createTestScope();\n        const validator = scope.resolve(validatorExecutor);\n        const result = validator.validate(input);\n        expect(result.isValid).toBe(expected);\n      });\n    });\n  });\n}\n// Usage\nconst emailValidationCases = [\n  { input: 'test@example.com', expected: true, description: 'should accept valid email' },\n  { input: 'invalid-email', expected: false, description: 'should reject invalid email' },\n  { input: '', expected: false, description: 'should reject empty email' },\n];\ndescribe('EmailValidator', () => {\n  testValidation(emailValidatorExecutor, emailValidationCases);\n});","performance-testing-utilities#Performance Testing Utilities":"","performance-measurement#Performance Measurement":"// test/performance.ts\nimport { performance } from 'perf_hooks';\nexport function measurePerformance<T>(\n  testFn: () => T,\n  maxDuration = 100\n): T {\n  const start = performance.now();\n  const result = testFn();\n  const end = performance.now();\n  const duration = end - start;\n  expect(duration).toBeLessThan(maxDuration);\n  return result;\n}\nexport async function measureAsyncPerformance<T>(\n  testFn: () => Promise<T>,\n  maxDuration = 100\n): Promise<T> {\n  const start = performance.now();\n  const result = await testFn();\n  const end = performance.now();\n  const duration = end - start;\n  expect(duration).toBeLessThan(maxDuration);\n  return result;\n}\n// Usage\ndescribe('Performance', () => {\n  it('should resolve quickly', () => {\n    measurePerformance(() => {\n      const scope = createTestScope();\n      return scope.resolve(complexExecutor);\n    }, 50); // Max 50ms\n  });\n  it('should handle async operations efficiently', async () => {\n    await measureAsyncPerformance(async () => {\n      const scope = createTestScope();\n      return scope.resolve(asyncExecutor);\n    }, 200); // Max 200ms\n  });\n});","memory-testing#Memory Testing":"// test/memory.ts\nexport function measureMemoryUsage<T>(\n  testFn: () => T,\n  maxMemoryIncrease = 1024 * 1024 // 1MB\n): T {\n  const initialMemory = process.memoryUsage().heapUsed;\n  const result = testFn();\n  \n  // Force garbage collection if available\n  if (global.gc) {\n    global.gc();\n  }\n  \n  const finalMemory = process.memoryUsage().heapUsed;\n  const memoryIncrease = finalMemory - initialMemory;\n  expect(memoryIncrease).toBeLessThan(maxMemoryIncrease);\n  return result;\n}\n// Usage\ndescribe('Memory Usage', () => {\n  it('should not leak memory', () => {\n    measureMemoryUsage(() => {\n      const scope = createTestScope();\n      // Create many executors\n      for (let i = 0; i < 1000; i++) {\n        scope.resolve(exec(() => i));\n      }\n      // Release scope\n      scope.release();\n    });\n  });\n});","integration-with-testing-frameworks#Integration with Testing Frameworks":"","jest-setup#Jest Setup":"// jest.config.js\nmodule.exports = {\n  preset: 'ts-jest',\n  testEnvironment: 'node',\n  setupFilesAfterEnv: ['<rootDir>/src/test/setup.ts'],\n  testMatch: ['**/__tests__/**/*.test.ts'],\n};\n// src/test/setup.ts\nimport { createTestScope } from './utils';\n// Global test utilities\nglobal.createTestScope = createTestScope;\n// Setup and teardown\nbeforeEach(() => {\n  // Reset any global state\n});\nafterEach(() => {\n  // Cleanup after each test\n});","vitest-configuration#Vitest Configuration":"// vitest.config.ts\nimport { defineConfig } from 'vitest/config';\nexport default defineConfig({\n  test: {\n    environment: 'jsdom',\n    setupFiles: ['./src/test/setup.ts'],\n    globals: true,\n    testTimeout: 10000,\n  },\n});","best-practices#Best Practices":"","1-organize-test-utilities#1. Organize Test Utilities":"// test/index.ts\nexport * from './utils';\nexport * from './builders';\nexport * from './mocks';\nexport * from './fixtures';\nexport * from './async-helpers';\nexport * from './reactive-helpers';\nexport * from './state-helpers';","2-use-consistent-naming#2. Use Consistent Naming":"// Clear naming conventions\ndescribe('UserService', () => {\n  describe('createUser', () => {\n    it('should create user with valid data', () => {\n      // Test implementation\n    });\n    it('should reject invalid email', () => {\n      // Test implementation\n    });\n  });\n});","3-document-test-utilities#3. Document Test Utilities":"/**\n * Creates a test scope with optional presets\n * @param presets - Optional preset values for executors\n * @returns A new test scope\n */\nexport function createTestScope(presets?: Preset[]): Scope {\n  return createScope(...(presets || []));\n}","next-steps#Next Steps":"Interactive Testing - Testing complex user interactions\nTesting Overview - Back to testing overview\nTesting Executors - Executor-specific testing\nThese testing utilities provide a comprehensive toolkit for testing Pumped Functions applications. They help reduce boilerplate, improve test readability, and ensure consistent testing practices across your codebase."}}}
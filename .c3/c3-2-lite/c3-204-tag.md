---
id: c3-204
c3-version: 3
title: Tag System
summary: >
  Metadata attachment and extraction with required, optional, and collect modes
  for cross-cutting data propagation.
---

# Tag System

## Overview {#c3-204-overview}
<!-- Metadata attachment and extraction -->

Tags provide a way to attach metadata that flows through the system:
- Attach values at scope, context, or execution level
- Extract values as dependencies in atoms and flows
- Support required, optional, and collect modes
- Enable cross-cutting concerns like tracing, authentication, tenant isolation

## Concepts {#c3-204-concepts}

### Tag Interface

```typescript
interface Tag<T, HasDefault extends boolean = false> {
  readonly [tagSymbol]: true
  readonly key: symbol           // Unique identifier
  readonly label: string         // Human-readable name
  readonly defaultValue: T | undefined
  readonly hasDefault: HasDefault
  readonly parse?: (raw: unknown) => T  // Optional validation
  (value: T): Tagged<T>          // Create tagged value
  get(source: TagSource): T      // Get required value
  find(source: TagSource): T | undefined  // Get optional value
  collect(source: TagSource): T[]  // Get all values
}
```

### Tagged Interface

A tagged value is a key-value pair:

```typescript
interface Tagged<T> {
  readonly [taggedSymbol]: true
  readonly key: symbol
  readonly value: T
}
```

### TagExecutor

Used as a dependency to extract tag values:

```typescript
interface TagExecutor<TOutput, TTag = TOutput> {
  readonly [tagExecutorSymbol]: true
  readonly tag: Tag<TTag, boolean>
  readonly mode: "required" | "optional" | "all"
}
```

## Creating Tags {#c3-204-creating}

### Basic Tag

```typescript
const userIdTag = tag<string>({ label: 'userId' })
```

### Tag with Default Value

```typescript
const localeTag = tag({
  label: 'locale',
  defaultValue: 'en-US'
})
```

### Creating Tagged Values

```typescript
const tagged = userIdTag('user-123')
// { [taggedSymbol]: true, key: Symbol(...), value: 'user-123' }
```

### Tag with Parse

Tags can include a parse function for runtime validation:

```typescript
const userId = tag({
  label: 'userId',
  parse: (raw) => {
    if (typeof raw !== 'string') throw new Error('Must be string')
    if (raw.length < 1) throw new Error('Cannot be empty')
    return raw
  }
})

// Validates on creation
userId('abc-123')  // OK
userId(123)        // Throws ParseError
```

**Parse behavior:**
- Runs synchronously when `tag(value)` is called
- Throws `ParseError` with `phase: 'tag'` on failure
- Type is inferred from parse return type
- Default values bypass parsing

## Tag Extraction Modes {#c3-204-modes}

### Required Mode

Throws if tag not found and no default:

```typescript
const myFlow = flow({
  deps: { userId: tags.required(userIdTag) },
  factory: (ctx, { userId }) => {
    // userId is string (never undefined)
  }
})
```

### Optional Mode

Returns undefined if not found (or default if defined):

```typescript
const myFlow = flow({
  deps: { traceId: tags.optional(traceIdTag) },
  factory: (ctx, { traceId }) => {
    // traceId is string | undefined
  }
})
```

### All Mode (Collect)

Returns array of all matching values:

```typescript
const myFlow = flow({
  deps: { allRoles: tags.all(roleTag) },
  factory: (ctx, { allRoles }) => {
    // allRoles is string[]
  }
})
```

## Tag Sources {#c3-204-sources}

### Scope Tags

Applied to all resolutions in the scope:

```typescript
const scope = await createScope({
  tags: [tenantTag('tenant-123')]
})
```

### Context Tags

Applied to all executions in the context:

```typescript
const ctx = scope.createContext({
  tags: [requestIdTag('req-456')]
})
```

### Execution Tags

Applied to a single execution:

```typescript
await ctx.exec({
  flow: myFlow,
  input: data,
  tags: [userIdTag('user-789')]
})
```

### Flow Tags

Attached to the flow definition:

```typescript
const adminFlow = flow({
  tags: [roleTag('admin')],
  factory: (ctx) => { ... }
})
```

### Tag Merge Order

Later sources override earlier (for single-value modes):

1. Flow tags
2. Scope tags
3. Context tags
4. Execution tags ← highest priority

For `tags.all()`, values from all sources are collected.

## Direct Tag Methods {#c3-204-methods}

### tag.get()

Get required value from source:

```typescript
const tags = [userIdTag('user-123')]

const userId = userIdTag.get(tags)
// 'user-123'

const missing = unknownTag.get(tags)
// Throws: "Tag 'unknownTag' not found"
```

### tag.find()

Get optional value from source:

```typescript
const tags = [userIdTag('user-123')]

const userId = userIdTag.find(tags)
// 'user-123'

const missing = unknownTag.find(tags)
// undefined (or default if tag has one)
```

### tag.collect()

Get all values from source:

```typescript
const tags = [roleTag('admin'), roleTag('editor'), roleTag('viewer')]

const roles = roleTag.collect(tags)
// ['admin', 'editor', 'viewer']
```

## Type Inference {#c3-204-types}

### TagExecutor Output Types

| Mode | Tag<T> | Output Type |
|------|--------|-------------|
| `tags.required(tag)` | `Tag<T>` | `T` |
| `tags.optional(tag)` | `Tag<T>` | `T \| undefined` |
| `tags.all(tag)` | `Tag<T>` | `T[]` |

### With Default Value

```typescript
const localeTag = tag({ label: 'locale', defaultValue: 'en-US' })

// tags.required(localeTag) → string (returns default if not found)
// tags.optional(localeTag) → string (returns default if not found)
// tags.all(localeTag) → string[] (doesn't include default)
```

## Type Guards {#c3-204-guards}

### isTag

```typescript
import { isTag } from '@pumped-fn/lite'

if (isTag(value)) {
  console.log('Label:', value.label)
}
```

### isTagged

```typescript
import { isTagged } from '@pumped-fn/lite'

if (isTagged(value)) {
  console.log('Key:', value.key)
  console.log('Value:', value.value)
}
```

### isTagExecutor

```typescript
import { isTagExecutor } from '@pumped-fn/lite'

if (isTagExecutor(dep)) {
  console.log('Mode:', dep.mode)
  console.log('Tag:', dep.tag.label)
}
```

## Common Patterns {#c3-204-patterns}

### Request Tracing

```typescript
const traceIdTag = tag<string>({ label: 'traceId' })

const tracedFlow = flow({
  deps: { traceId: tags.optional(traceIdTag) },
  factory: async (ctx, { traceId }) => {
    console.log(`[${traceId ?? 'no-trace'}] Processing...`)
    return result
  }
})

await ctx.exec({
  flow: tracedFlow,
  input: data,
  tags: [traceIdTag(generateTraceId())]
})
```

### Multi-Tenancy

```typescript
const tenantTag = tag<string>({ label: 'tenant' })

const tenantDbAtom = atom({
  deps: { tenantId: tags.required(tenantTag) },
  factory: (ctx, { tenantId }) => {
    return connectToTenantDb(tenantId)
  }
})
```

### Role-Based Access

```typescript
const roleTag = tag<string>({ label: 'role' })

const checkRoles = flow({
  deps: { roles: tags.all(roleTag) },
  factory: (ctx, { roles }) => {
    return roles.includes('admin')
  }
})

await ctx.exec({
  flow: checkRoles,
  input: null,
  tags: [roleTag('user'), roleTag('editor')]
})
// Returns false (no 'admin' role)
```

## Performance Note {#c3-204-performance}

Tag lookup uses O(n) linear array scan:
- Optimal for typical use (<10 tags per source)
- For 50+ tags, consider `@pumped-fn/core-next` with O(1) Map-based lookup

## Source Files {#c3-204-source}

| File | Contents |
|------|----------|
| `src/tag.ts` | `tag()`, `tags`, `isTag()`, `isTagged()`, `isTagExecutor()` |
| `src/types.ts` | `Tag`, `Tagged`, `TagExecutor`, `TagSource` |
| `src/symbols.ts` | `tagSymbol`, `taggedSymbol`, `tagExecutorSymbol` |

## Testing {#c3-204-testing}

Key test scenarios in `tests/tag.test.ts`:
- Tag creation with/without default
- Tagged value creation
- get/find/collect methods
- Type guards
- Missing tag behavior

## Related {#c3-204-related}

- [c3-202](./c3-202-atom.md) - Tag dependencies in atoms
- [c3-203](./c3-203-flow.md) - Tag dependencies in flows
- [c3-201](./c3-201-scope.md) - Scope and context tag propagation

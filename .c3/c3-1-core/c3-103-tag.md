---
id: c3-103
c3-version: 3
title: Tag System
summary: >
  Metadata attachment and extraction for executors, flows, and scopes.
---

# Tag System

## Overview {#c3-103-overview}
<!-- Metadata management -->

The Tag system provides type-safe metadata attachment and extraction:

- **Tag** - A callable metadata definition with schema validation
- **Tagged** - A concrete value attached to a tag
- **Sources** - Where tags can be read from (Store, Container, Array)
- **TagExecutor** - Dependency syntax for resolving tags

Tags enable cross-cutting metadata (tracing IDs, tenant context, feature flags) to flow through the system without polluting function signatures.

## Concepts {#c3-103-concepts}

### Tag

A tag is a metadata definition that:

1. **Has a key** - Unique symbol for identification
2. **Has a schema** - Validates values on read/write
3. **Is callable** - `myTag(value)` creates a Tagged value
4. **Has extraction methods** - For reading from various sources

**Creating tags:**

| Pattern | Result |
|---------|--------|
| `tag(schema)` | Tag without default (required) |
| `tag(schema, { label })` | Named tag (better debugging) |
| `tag(schema, { default })` | Tag with default value |
| `tag(schema, { label, default })` | Named tag with default |

**Tag type parameter:**
- `Tag<T, false>` - No default, `readFrom` returns `T | undefined`
- `Tag<T, true>` - Has default, `readFrom` always returns `T`

### Tagged

A Tagged value is what you attach to executors, flows, or scopes:

```typescript
const retryTag = tag(custom<number>(), { label: "retry", default: 3 })

const tagged = retryTag(5)  // Tagged<number>
// { key: Symbol(retry), value: 5, schema: ... }
```

Tagged values are attached via:
- Executor creation: `provide(factory, myTag(value))`
- Flow creation: `flow(handler, myTag(value))`
- Scope creation: `createScope({ tags: [myTag(value)] })`
- Execution: `scope.exec({ flow, input, tags: [myTag(value)] })`

### Sources

Tags can be extracted from three source types:

| Source Type | Interface | Use Case |
|-------------|-----------|----------|
| **Store** | `{ get(key), set(key, value) }` | ExecutionContext.tagStore |
| **Container** | `{ tags?: Tagged[] }` | Executors, flows, scopes |
| **Tagged[]** | Array of Tagged | Direct tag arrays |

The extraction methods handle all source types transparently.

### Extraction Modes

| Method | Behavior | When Missing |
|--------|----------|--------------|
| `extractFrom(source)` | Get value | Throws error (unless has default) |
| `readFrom(source)` | Get value | Returns undefined (or default) |
| `collectFrom(source)` | Get all values | Returns empty array |

**Hierarchy:**
When reading from ExecutionContext, tags are searched in order:
1. Context's own tags
2. Parent context tags (nested flows)
3. Scope tags

### Tag Dependencies

Tags can be used as dependencies in `derive()`:

| Helper | Mode | Output Type |
|--------|------|-------------|
| `tags.required(tag)` | extract | `T` (throws if missing) |
| `tags.optional(tag)` | read | `T \| undefined` |
| `tags.all(tag)` | collect | `T[]` |

**Example:**
```typescript
const tenantId = tag(custom<string>(), { label: "tenantId" })

const userRepo = derive(
  { db: dbExecutor, tenant: tags.required(tenantId) },
  ({ db, tenant }) => new UserRepo(db, tenant)
)
```

## Writing Tags {#c3-103-writing}

| Method | Target | Effect |
|--------|--------|--------|
| `writeToStore(store, value)` | Tag.Store | Directly set in store |
| `writeToContainer(container, value)` | Container | Push to `tags` array |
| `writeToTags(array, value)` | Tagged[] | Push to array |
| `injectTo(store, value)` | Tag.Store | Alias for writeToStore |

**In ExecutionContext:**
```typescript
ctx.set(myTag, value)  // Writes to context's tag store
```

## Validation {#c3-103-validation}

Tags validate values on both read and write:

1. **On write** - Value validated against schema before storing
2. **On read** - Value validated against schema before returning

This ensures type safety even when tags cross system boundaries.

**Caching:**
Validated values are cached per-source to avoid repeated validation. Cache is invalidated when values change.

## Common Patterns {#c3-103-patterns}

### Request Context

```typescript
const requestId = tag(custom<string>(), { label: "requestId" })
const userId = tag(custom<string>(), { label: "userId" })

const myFlow = flow((ctx, input) => {
  const reqId = ctx.get(requestId)
  const user = ctx.find(userId) // may be undefined
  // ...
})

scope.exec({
  flow: myFlow,
  input: data,
  tags: [requestId(uuid()), userId(currentUser.id)]
})
```

### Feature Flags

```typescript
const featureFlags = tag(custom<Set<string>>(), {
  label: "features",
  default: new Set()
})

const handler = flow((ctx, input) => {
  const flags = ctx.get(featureFlags)
  if (flags.has("new-algorithm")) {
    // use new algorithm
  }
})
```

### Tracing

```typescript
const traceId = tag(custom<string>(), { label: "traceId" })
const spanId = tag(custom<string>(), { label: "spanId" })

const tracingExtension: Extension.Extension = {
  wrap: (operation, next) => {
    if (operation.kind === "execution") {
      const trace = operation.context.find(traceId)
      console.log(`[${trace}] Starting ${operation.target.type}`)
    }
    return next()
  }
}
```

## Type Guards {#c3-103-guards}

| Guard | Checks |
|-------|--------|
| `isTag(value)` | Value is a Tag (has extractFrom/readFrom/collectFrom) |
| `isTagged(value)` | Value is Tagged (has tagSymbol=true, key, value) |
| `isTagExecutor(value)` | Value is TagExecutor (has extraction mode) |

## Configuration {#c3-103-config}

**Tag options:**

| Option | Type | Purpose |
|--------|------|---------|
| `label` | string | Human-readable name (also used for Symbol.for) |
| `default` | T | Default value when not found |

**Label behavior:**
- With label: `Symbol.for(label)` - same label = same key
- Without label: `Symbol()` - unique key per tag instance

## Source Files {#c3-103-source}

| File | Contents |
|------|----------|
| `tag.ts` | Tag creation, type guards, tag executors (required/optional/all), merge utilities |
| `types.ts` | Tag namespace types (Store, Tagged, Container, Source) |

## Testing {#c3-103-testing}

Primary tests: `tag.test.ts`

Key test scenarios:
- Tag creation with/without defaults
- Extraction from all source types
- Validation on read/write
- Concurrent access patterns
- Cache invalidation
- TagExecutor resolution in derive()

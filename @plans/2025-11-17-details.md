# PR 117 Review Follow-up (spread tags syntax)

**Date**: 2025-11-17  
**Status**: Ready for execution  
**Review source**: https://github.com/pumped-fn/pumped-fn/pull/117#issuecomment-3539695175

## Brainstorm (superpowers:brainstorming)
- Option A: touch only the exact lines singled out by the reviewer, minimal edits, higher risk of regressions because duplicated logic stays scattered
- Option B: consolidate detection + merging helpers, add runtime guards, expand docs/tests so pumped-design skill has one authoritative story
- Option C: revert to earlier simpler API and re-implement spread tags from scratch (large scope, not needed)

Pick Option B: medium effort, highest clarity, keeps pumped-pattern enforceable.

## Review issues recap
1. Dependency detection logic duplicated (flow.ts:1110-1115 vs 1199-1207)
2. Tag merging repeated in executeJournaledFlow, executeNonJournaledFlow, Scope["~executeFlow"]
3. Handler type assertion at flow.ts:1132 lacks runtime validation (review suggested comment; we prefer guard to avoid comments)
4. Missing tests for empty dependency object `{}` + undefined tag entries inside spread params
5. Documentation/skill references need to capture empty dependency behavior + spread-tag edge cases, optional diagram for propagation flow
6. Reviewer reminded to re-run typecheck + test commands

## Workstreams (detailed)

- [x] **Operational note**
  - [x] After completing each checkbox item, append any missing contextual details (new decisions, clarifications, edge cases) directly to this plan so future steps have full information.

- [x] **Normalize dependency detection (`packages/next/src/flow.ts`)**
  - [x] Add helper near other flow utilities (top of file or dedicated `packages/next/src/flow/dependencies.ts`) _(done: defined `isPlainObject`, `isDefineConfig`, `isDependencyCandidate`, `isDependencyCollection` in `packages/next/src/flow.ts`, allowing empty arrays/records for compatibility and rejecting config-shaped objects)_:
   ```ts
   const isDependencyCollection = (value: unknown): value is Core.DependencyLike => {
     if (!value) return false;
     if (isExecutor(value)) return true;
     if (Array.isArray(value)) return value.every(isExecutor);
     if (typeof value !== "object") return false;
     if ("input" in (value as Record<string, unknown>) && "output" in (value as Record<string, unknown>)) return false;
     const entries = Object.values(value as Record<string, unknown>);
     return entries.length > 0 && entries.every(item => typeof item === "function" || isExecutor(item));
   };
   ```
   - Enforce `entries.length > 0` intentionally; support `{}` via explicit branch (if we keep `{}` valid return true but include explanatory constant + tests).
  - [x] Replace inline `isSingleDep`/`isMultiDep` logic with helper:
    - `const isHandlerOnly = typeof first === "function";`
    - `const hasDeps = !isHandlerOnly && isDependencyCollection(first);`
  - [x] Remove inline `isValidDependencyObject` branch; reuse helper when first argument is object.
  - [x] Guard config branch by checking `isDefineConfig(first)` (still verifying `input`/`output`).
  - [x] Use helper to compute `hasDeps` for tag extraction block so tag collection paths become unambiguous.
  - [x] Update TypeScript types so `dependencies` variable deduced via helper (no casts). Where necessary add temporary generics `const deps = first as D` only after helper narrow. _(done: introduced `attachDependencies` helper in `packages/next/src/flow.ts` which captures the dependency type parameter so calls in dependency + config branches no longer need `as D` when invoking `def.handler`; only handler-shape narrowing remains, tracked under Workstream 3)_
  - [x] Extend `packages/next/tests/flow-execution.test.ts` to assert helper-driven behavior:
    - Extend `packages/next/tests/flow-execution.test.ts` to assert helper-driven behavior:
      - Accept array of executors `[provide(() => 1)]`.
      - Accept record map `{ depA: provide(...) }`.
      - Accept empty record if spec says allowed (document expectation). If allowed, add test verifying `flow({}, handler, tag)` works; if disallowed, adjust error expectation.
     - Reject plain object with `input`/`output`.
     - Reject object mixing invalid values (numbers, null).
   - Each test should assert thrown message matches updated strings.

- [x] **Centralize tag merging (flow + scope layers)**
  - [x] Create helper `mergeFlowTags` in `packages/next/src/tags/merge.ts` (or `packages/next/src/flow/tag-helpers.ts`) _(done: new module accepts `ReadonlyArray<Tag.Tagged | undefined>` inputs so flow + scope can pass optional entries; helper filters falsy values while preserving ordering)_:
    ```ts
    export const mergeFlowTags = (
      definitionTags?: ReadonlyArray<Tag.Tagged | undefined>,
      executionTags?: ReadonlyArray<Tag.Tagged | undefined>
    ): Tag.Tagged[] | undefined => {
      const hasDefinition = !!definitionTags && definitionTags.length > 0;
      const hasExecution = !!executionTags && executionTags.length > 0;
      if (!hasDefinition && !hasExecution) {
        return undefined;
      }
      const merged: Tag.Tagged[] = [];
      if (definitionTags) {
        definitionTags.forEach((tag) => {
          if (tag) merged.push(tag);
        });
      }
      if (executionTags) {
        executionTags.forEach((tag) => {
          if (tag) merged.push(tag);
        });
      }
      return merged.length > 0 ? merged : undefined;
    };
    ```
  - [x] Update `executeJournaledFlow`, `executeNonJournaledFlow`, and `Scope["~executeFlow"]` to call helper instead of inline arrays. Ensure resulting context receives merged tags reference _(done in `packages/next/src/flow.ts` and `packages/next/src/scope.ts`, contexts now read helper output)_.
  - [x] Add fast path fallback `mergedTags ?? undefined` to avoid new allocations when no tags _(handled by helper returning `undefined` when both inputs empty)_.
  - [x] Validate helper is reused anywhere else we combine tags (search `...(definition.tags`) _(current matches limited to flow.ts + scope.ts; `rg mergeFlowTags` confirms intended call sites + tests only)_.
  - [x] Add tests:
    - [x] Add spec in `packages/next/tests/scope-run.test.ts` verifying merged order = `[definitionTags..., executionTags...]` and no undefined entries _(new `scope tag merging` suite captures `FlowContext.tags` via extension and ensures helper filters undefined before hitting context)_.
    - [x] Add spec ensuring calling helper with both undefined returns undefined (makes FlowContext skip passing `tags`) _(direct helper tests cover undefined inputs + no-tags scenarios)_.
  - [ ] Update any exposures (maybe `FlowDefinition.tags` usage) referencing new helper logic in docs.

- [x] **Handler/runtime guard instead of assertion (`packages/next/src/flow.ts`)**
  - [x] Enforce runtime rejection of tag factories masquerading as handlers (implemented `isTag` checks before every handler branch so `flow(tag(), ...)` surfaces concise error instead of misinterpreting tags).
  - [x] Use guard in handler-only branch:
    - Added `if (isTag(first)) throw new Error("flow(handler) requires handler function")` before defining handler; type assertions remain for now because handler overload relies on generics, but runtime validation now blocks invalid inputs.
  - [x] Use guard in dependency branch for `second`/`third` positions:
    - `flow(deps, handler)` now checks `typeof second === "function"` and `!isTag(second)`; config + deps path verifies `third` is a real function (non-tag) before invoking.
    - Error strings kept terse per CLAUDE.md.
  - [x] For config branch, reuse guard logic to ensure provided handler type is correct before passing to `def.handler` (both direct handler and config+deps+handler forms updated).
  - [x] Remove `(ctx?: Flow.Context) => Promise<S> | S` overload from `flowImpl` signature if unnecessary (was to allow zero-input flows). If still needed, guard ensures `ctx` optional flows still pass runtime check. _(done: removed the optional-context overloads + union entry in `packages/next/src/flow.ts`; single-argument handlers still compile because TS allows passing functions with fewer parameters)._
  - [x] Confirm TypeScript inference unaffected by guard introduction by running `pnpm -F @pumped-fn/core-next typecheck` + `test` (latest run succeeded after guard changes; dependency casts now routed through `attachDependencies` helper).

- [x] **Edge-case tests + documentation**
  - [ ] Tests (all in `packages/next/tests/flow-execution.test.ts`):
    - `flow({}, handler, tag)` or updated expectation if `{}` invalid.
    - [x] `flow(handler, tag1, undefined, tag2)` ensures undefined spread entries dropped without shifting order (result tags array equals `[tag1, tag2]`). _(done via `flow() ignores undefined spread entries...` test lines 370-380; filters tag array by keys so FlowDefinition meta tags don't break expectations.)_
    - [x] Additional test verifying runtime tag merging between flow definitions and execution tags. _(added `flow.execute merges definition tags with execution tags` at lines 412-424 to prove `mergeFlowTags` behavior during `flow.execute` calls.)_
  - [x] Docs updates:
    - `docs/plans/2025-01-13-flow-tags-spread-syntax-design.md`: added “Edge Cases & Tag Merging” section plus mermaid diagram showing FlowDefinition/execution tags feeding FlowContext via `mergeFlowTags`.
    - `.claude/skills/pumped-design/references/tags.md`: documented definition vs execution tag merging and pointed to `packages/next/src/tags/merge.ts`.
    - `.claude/skills/pumped-design/references/flow-context.md`: new Tag Inheritance note describing how FlowContext receives merged tags and how undefined entries are filtered.
    - Updated `docs/guides/05-flow.md` with a “Spread Tags + Execution Tags” section covering conditional spreads, ignored `undefined` entries, and runtime tag merging via `flow.execute`.
  - [x] Examples:
    - Added `examples/flow-spread-tags.ts` demonstrating conditional spread tags (`...` array) plus execution tag overrides.

- [x] **Knowledge artifacts + catalog alignment**
  - [x] Extend relevant existing plan/design docs referencing previous duplication (added pointer in `docs/plans/2025-11-13-consolidate-tag-tests.md` to the new helper reference so tag work stays connected).
  - [x] Add short knowledge capsule (`docs/plans/2025-11-17-flow-tag-helpers.md`) summarizing helper so future tasks reuse pattern.
  - [x] Ensure `.claude/skills/pumped-design/references` caches mention helper file path so pumped-design skill surfaces right snippet (tags + flow-context references now mention `packages/next/src/tags/merge.ts` and runtime merging).
  - [x] Validate mermaid diagram referenced above renders without local file path using `${SUPERPOWERS_SKILLS_ROOT}` placeholders if necessary. _(diagram uses inline node labels only, no absolute paths)_

- [x] **Verification + gating**
  - [x] After code + docs updates run commands in repo root:
    - `pnpm -F @pumped-fn/core-next typecheck`
    - `pnpm -F @pumped-fn/core-next typecheck:full`
    - `pnpm -F @pumped-fn/core-next test`
    - `pnpm -F @pumped-fn/examples typecheck`
  - [x] Capture logs or summaries for final response; ensure no transient warnings ignored. _(latest runs captured vitest output + note about expected extension error log)_
  - [x] Search repo for `mergeFlowTags` and `isDependencyCollection` to ensure only intended references exist. _(ran `rg`, confirmed only flow.ts/scope.ts/tests/docs references expected)_
  - [x] Confirm no comments introduced (per CLAUDE.md). Rely on naming instead. _(No inline comments added during this pass; only plan/docs updates.)_
  - [x] Final audit: run `rg "Invalid tag" packages/next/src/flow.ts` verifying error text matches new requirement.

## Deliverables
- Refactored `packages/next/src/flow.ts` and `packages/next/src/scope.ts` helper usage
- Added helper module + guard implementations (likely `packages/next/src/tags/*` or utility namespace)
- Updated tests + docs + pumped-design references
- Verification logs for required pnpm targets
